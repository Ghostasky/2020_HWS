{
    "docs": [
        {
            "location": "/index.html",
            "text": "Getting Started\n\n\nThis document is a usage manual for JEB version 2. Last revision: \nOctober 25, 2017\n. The latest version of this manual can be found \nonline on the PNF Software web site\n.\n\n\nJEB is a reverse-engineering platform to perform disassembly, decompilation, debugging, and analysis of code and document files, manually or as part of an analysis pipeline.\n\n\n\n\nThe first part of this guide is a \nuser manual\n that covers basic usage related to analyzing, decompiling and debugging applications (Android apps, as well as native binaries). It is not an exhaustive resource. We recommend visiting our \nblog\n for additional, pointed resources describing a variety of use cases.\n\n\nThe second half is a \ndeveloper portal\n for advanced users who will want to use the JEB API to script tasks, develop plugins, or even craft their own front-ends. Alongside these pages, the \nAPI reference documentation website\n will be an indispensable resource. \n\n\n\n\n\n\nNote to JEB 1.x users:\n JEB2 also ships with modules to analyze Android applications. Generally, JEB2 can be seen as a superset of JEB1.\n\n\n\n\nInstallation\n\n\nSoftware Package\n\n\nThe software package is distributed as a zip archive, custom-generated for each registered user. It contains the back-end components as well as the reference front-end implementation for desktop platforms, referred to as the \"RCP client\". \nThis manual focuses mostly on using JEB through the RCP client.\n\n\nThe RCP client client runs on \nWindows\n, \nLinux\n, and \nmacOS\n (formerly OS X) operating systems, \n32-bit\n and \n64-bit\n versions.\n\n\nRequirements\n\n\nJava\n\n\nJEB requires a \nJava Runtime Environment (JRE)\n or Java Development Kit (JDK) version 8. (Note that jeb.jar works with older JRE 7, or newer JRE 9; however, the UI desktop client requires a JRE 8.)\n\n\nUI Support Package\n\n\nThe RCP client requires a \nsupport package\n. The support package contains common graphical framework components based on the \nEclipse Rich Client Platform framework\n.\n\n\n\n\nIf you are running JEB on an Internet-connected computer, the latest and most appropriate version of the support package for your system will be downloaded and installed.\n\n\nIf you are running JEB within a limited connectivity environment, you will need to download the support package manually. See below.\n\n\n\n\nSetup\n\n\nMake sure you have a JRE or JDK installed.\n\n\n\n\nThe \njava\n binary must be accessible from the \nPATH\n environment variable.\n\n\nOptionally, you may also want to set a \nJAVA_HOME\n environment variable pointing to your Java installation folder.\n\n\n\n\n\n\n64-bit or 32-bit:\n if you are running on a 64-bit system, we recommend you install and use a 64-bit Java environment. A common source of problems are 64-bit systems having a 32-bit JRE accessible from the PATH. You may have different versions of Java installed, but always make sure that the PATH refers to one that matches your system specifications.\n\n\n\n\nThen, unpack your JEB zip archive into the folder of your choice. Make sure that the folder and its contents are recursively user-writeable.\n\n\nOptional step:\n If you are running JEB within a limited connectivity environment, you must download a support package manually:\n\n\n\n\nVisit the \nSupport Package page\n\n\nDownload the package appropriate for your environment\n\n\nDrop it into the \n[JEB_FOLDER]/bin/\n directory \n\n\n\n\nStartup\n\n\nNext, execute the startup script appropriate for your environment:\n\n\n\n\nOn Windows: execute \njeb_wincon.bat\n\n\nOn Linux: execute \njeb_linux.sh\n. \n\n\nOn MacOS: execute \njeb_macos.sh\n\n\n\n\nIf a support package was not found in the \nbin/\n folder, an appropriate one will be downloaded automatically. \nIf your system is not connected to the Internet, you must download one manually! Please read the \nsection above\n before proceeding.\n\n\nThe startup script will then locate and decrypt the JEB binary file. It may prompt the user and ask for the decryption password, which can be found within your software delivery note, such as update emails received from PNF Software. Enter the password to allow the startup script to finish the installation process. JEB will start and the software logo should pop up:\n\n\n\n\nRegistration\n\n\nUpon first run of a JEB, or the controller part of floating build, the user is required to generate a license key:\n\n\n\n\n\n\n\n\nFor JEB \n= 2.2.10, the license key can be automatically generated by clicking on \"Generate a Key\".\n\n\n\n\n\n\nFor JEB \n 2.2.10, you have to manually generate the license key by visiting the \nmentioned URL\n and input the \nLicense data\n blob:\n\n\n\n\n\n\n\n\nThe possibility to generate a key is conditioned by the number of licenses attached to a given build. The key will be stored in the \nbin/jeb-client.cfg\n file, under the \n.LicenseKey\n key entry. \nA key is specific to the user-account and machine configuration on which JEB is running!\n Do not attempt to reuse a key on another system.\n\n\n\n\nNote\n: If you need to deprecate an older key (eg, because of a machine replacement, user departure, or else), email \nsupport\n. We handle those queries as quickly as we can, generally within minutes of processing your email.\n\n\n\n\nFirst use\n\n\nCongratulation! JEB is now running.\n\n\nWorkspace\n\n\nYou should be greeted by an empty workspace, using the default 3-part layout:\n\n\n\n\nProject explorer on the left side\n\n\nLogger and Console at the bottom\n\n\nEmpty area in the center\n\n\n\n\n\n\nStarting an Analysis\n\n\nLet's open our first file in JEB. Go ahead and download \nRaasta.apk\n, a sample (clean) Android application that will serve as our testing ground for the next couple of chapters.\n\n\nOpen it via the \nFile\n menu. A new project will be created with a single artifact, Raasta.apk.\n\n\nThe application is processed by various Android analysis plugins:\n\n\n\n\nThe APK plugin takes care of unbundling the app, decoding the manifest and resources\n\n\nThe DEX plugin performs the analysis and disassembly of the DEX bytecode file (or files)\n\n\nThe XML parser analyzes XML resources\n\n\nThe Certificate plugin analyzes the certificate\n\n\n... and so on.\n\n\n\n\n\n\nNote\n: JEB performs recursive analysis on input artifacts and units, using the loaded \nparser plugins\n.\n\n\n\n\nThe project explorer tree should display a Bytecode node, representing the \nDEX unit\n (more on the concept of \nunits\n later). The DEX views should be opened automatically by the RCP client, as they are detected as the principal views of an APK artifact.\n\n\nYour workspace should look like:\n\n\n\n\nThe workspace can be customized by the user:\n\n\n\n\nViews can be dragged and dropped, resized, stacked and docked with other views\n\n\nViews can be maximized (by double-clicking on the view title bar), minimized, or even detached and placed in separate windows - something particularly particularly useful for multi-monitor setups.\n\n\nUsers can also fork, customize, and save layouts, via the \nWindow\n menu. It is particularly useful to create custom layouts when reverse-engineering with many views, such as during a debugging session.\n\n\n\n\n\n\nTerminology\n\n\nThe Project Explorer contains three types of nodes:\n\n\n\n\nThe top-most entity accessible within the RCP client is a \nproject\n\n\nCurrently, the RCP client can only handle a single project per session\n\n\n\n\n\n\nA project contains various \nartifacts\n, which represent data to be analyzed\n\n\nArtifacts are usually files read from the local file system\n\n\n\n\n\n\nThe analysis of artifacts yield \nunits\n and \nsub-units\n\n\nEx: Analyzing an Android DEX file artifact will yield at least one DEX unit representing the bytecode of that DEX file\n\n\n\n\n\n\nUsers interact with units through \nviews\n that contain \nfragments\n representing various aspects of a unit\n\n\nWithin the RCP client, fragments are visible as tabs at the bottom of a view\n\n\n\n\n\n\nMost units are \ninteractive\n. Users can interact with them through a variety of ways, including via \nActions\n, available in the similarly-named menu. \n\n\nExample: an Android Bytecode file artifact (classes.dex), after analysis, will yield a DEX unit that represents the bytecode of that DEX file.\n\n\n\n\n\n\n\n\n\n\nIn the next section, we will show what actions can be performed to make the analysis of code interactive.",
            "title": "Getting Started"
        },
        {
            "location": "/index.html#getting-started",
            "text": "This document is a usage manual for JEB version 2. Last revision:  October 25, 2017 . The latest version of this manual can be found  online on the PNF Software web site .  JEB is a reverse-engineering platform to perform disassembly, decompilation, debugging, and analysis of code and document files, manually or as part of an analysis pipeline.   The first part of this guide is a  user manual  that covers basic usage related to analyzing, decompiling and debugging applications (Android apps, as well as native binaries). It is not an exhaustive resource. We recommend visiting our  blog  for additional, pointed resources describing a variety of use cases.  The second half is a  developer portal  for advanced users who will want to use the JEB API to script tasks, develop plugins, or even craft their own front-ends. Alongside these pages, the  API reference documentation website  will be an indispensable resource.     Note to JEB 1.x users:  JEB2 also ships with modules to analyze Android applications. Generally, JEB2 can be seen as a superset of JEB1.",
            "title": "Getting Started"
        },
        {
            "location": "/index.html#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/index.html#software-package",
            "text": "The software package is distributed as a zip archive, custom-generated for each registered user. It contains the back-end components as well as the reference front-end implementation for desktop platforms, referred to as the \"RCP client\".  This manual focuses mostly on using JEB through the RCP client.  The RCP client client runs on  Windows ,  Linux , and  macOS  (formerly OS X) operating systems,  32-bit  and  64-bit  versions.",
            "title": "Software Package"
        },
        {
            "location": "/index.html#requirements",
            "text": "",
            "title": "Requirements"
        },
        {
            "location": "/index.html#java",
            "text": "JEB requires a  Java Runtime Environment (JRE)  or Java Development Kit (JDK) version 8. (Note that jeb.jar works with older JRE 7, or newer JRE 9; however, the UI desktop client requires a JRE 8.)",
            "title": "Java"
        },
        {
            "location": "/index.html#ui-support-package",
            "text": "The RCP client requires a  support package . The support package contains common graphical framework components based on the  Eclipse Rich Client Platform framework .   If you are running JEB on an Internet-connected computer, the latest and most appropriate version of the support package for your system will be downloaded and installed.  If you are running JEB within a limited connectivity environment, you will need to download the support package manually. See below.",
            "title": "UI Support Package"
        },
        {
            "location": "/index.html#setup",
            "text": "Make sure you have a JRE or JDK installed.   The  java  binary must be accessible from the  PATH  environment variable.  Optionally, you may also want to set a  JAVA_HOME  environment variable pointing to your Java installation folder.    64-bit or 32-bit:  if you are running on a 64-bit system, we recommend you install and use a 64-bit Java environment. A common source of problems are 64-bit systems having a 32-bit JRE accessible from the PATH. You may have different versions of Java installed, but always make sure that the PATH refers to one that matches your system specifications.   Then, unpack your JEB zip archive into the folder of your choice. Make sure that the folder and its contents are recursively user-writeable.  Optional step:  If you are running JEB within a limited connectivity environment, you must download a support package manually:   Visit the  Support Package page  Download the package appropriate for your environment  Drop it into the  [JEB_FOLDER]/bin/  directory",
            "title": "Setup"
        },
        {
            "location": "/index.html#startup",
            "text": "Next, execute the startup script appropriate for your environment:   On Windows: execute  jeb_wincon.bat  On Linux: execute  jeb_linux.sh .   On MacOS: execute  jeb_macos.sh   If a support package was not found in the  bin/  folder, an appropriate one will be downloaded automatically.  If your system is not connected to the Internet, you must download one manually! Please read the  section above  before proceeding.  The startup script will then locate and decrypt the JEB binary file. It may prompt the user and ask for the decryption password, which can be found within your software delivery note, such as update emails received from PNF Software. Enter the password to allow the startup script to finish the installation process. JEB will start and the software logo should pop up:",
            "title": "Startup"
        },
        {
            "location": "/index.html#registration",
            "text": "Upon first run of a JEB, or the controller part of floating build, the user is required to generate a license key:     For JEB  = 2.2.10, the license key can be automatically generated by clicking on \"Generate a Key\".    For JEB   2.2.10, you have to manually generate the license key by visiting the  mentioned URL  and input the  License data  blob:     The possibility to generate a key is conditioned by the number of licenses attached to a given build. The key will be stored in the  bin/jeb-client.cfg  file, under the  .LicenseKey  key entry.  A key is specific to the user-account and machine configuration on which JEB is running!  Do not attempt to reuse a key on another system.   Note : If you need to deprecate an older key (eg, because of a machine replacement, user departure, or else), email  support . We handle those queries as quickly as we can, generally within minutes of processing your email.",
            "title": "Registration"
        },
        {
            "location": "/index.html#first-use",
            "text": "Congratulation! JEB is now running.",
            "title": "First use"
        },
        {
            "location": "/index.html#workspace",
            "text": "You should be greeted by an empty workspace, using the default 3-part layout:   Project explorer on the left side  Logger and Console at the bottom  Empty area in the center",
            "title": "Workspace"
        },
        {
            "location": "/index.html#starting-an-analysis",
            "text": "Let's open our first file in JEB. Go ahead and download  Raasta.apk , a sample (clean) Android application that will serve as our testing ground for the next couple of chapters.  Open it via the  File  menu. A new project will be created with a single artifact, Raasta.apk.  The application is processed by various Android analysis plugins:   The APK plugin takes care of unbundling the app, decoding the manifest and resources  The DEX plugin performs the analysis and disassembly of the DEX bytecode file (or files)  The XML parser analyzes XML resources  The Certificate plugin analyzes the certificate  ... and so on.    Note : JEB performs recursive analysis on input artifacts and units, using the loaded  parser plugins .   The project explorer tree should display a Bytecode node, representing the  DEX unit  (more on the concept of  units  later). The DEX views should be opened automatically by the RCP client, as they are detected as the principal views of an APK artifact.  Your workspace should look like:   The workspace can be customized by the user:   Views can be dragged and dropped, resized, stacked and docked with other views  Views can be maximized (by double-clicking on the view title bar), minimized, or even detached and placed in separate windows - something particularly particularly useful for multi-monitor setups.  Users can also fork, customize, and save layouts, via the  Window  menu. It is particularly useful to create custom layouts when reverse-engineering with many views, such as during a debugging session.",
            "title": "Starting an Analysis"
        },
        {
            "location": "/index.html#terminology",
            "text": "The Project Explorer contains three types of nodes:   The top-most entity accessible within the RCP client is a  project  Currently, the RCP client can only handle a single project per session    A project contains various  artifacts , which represent data to be analyzed  Artifacts are usually files read from the local file system    The analysis of artifacts yield  units  and  sub-units  Ex: Analyzing an Android DEX file artifact will yield at least one DEX unit representing the bytecode of that DEX file    Users interact with units through  views  that contain  fragments  representing various aspects of a unit  Within the RCP client, fragments are visible as tabs at the bottom of a view    Most units are  interactive . Users can interact with them through a variety of ways, including via  Actions , available in the similarly-named menu.   Example: an Android Bytecode file artifact (classes.dex), after analysis, will yield a DEX unit that represents the bytecode of that DEX file.      In the next section, we will show what actions can be performed to make the analysis of code interactive.",
            "title": "Terminology"
        },
        {
            "location": "/actions/index.html",
            "text": "Common Actions\n\n\nOne principal intended use for JEB is the analysis of binary code. This section focuses on the basics of \ncode analysis and refactoring\n, such as:\n\n\n\n\nrenaming items such as methods or fields\n\n\nchanging the code structure by moving items to packages \n\n\ncommenting\n\n\nnavigating a code base via cross-references\n\n\nviewing type hierarchies\n\n\netc.\n\n\n\n\nIn the RCP client, many interactions can be achieved via the \nAction\n and \nNavigation\n menus. Those actions are implemented by most JEB analysis modules that perform code disassembly.\n\n\n\n\n\n\nNote\n: Other action groups such as \nNative code actions\n and \nDebugging actions\n are detailed in later sections.\n\n\nNote\n: The examples in this section are based on the analysis of \nRaasta.apk\n using the Android DEX parser. \nKeep in mind that features and behaviors of \nActions\n depend on the module implementing and performing them.\n\n\n\n\nRenaming\n\n\nAn important requirement for analysts is the ability to rename code items such as types, methods and routines, fields and data items, packages, etc. consistently across a code base.\n\n\n\n\nPosition the caret on the item to be renamed\n\n\nHit the \nN\n key or select \nAction, Rename\n\n\nEnter the new name and press Enter\n\n\n\n\n\n\nTip:\n Within the Rename dialog box, press Ctrl+Space to bring up your renaming history.\n\n\n\n\n\n\nCommenting\n\n\nAnywhere in the code, press the \n/\n (slash) key to add a comment. Comments are attached to addresses or items.  \n\n\n\n\nNavigating\n\n\nPressing the \nEnter\n key on an item or double-clicking it will bring the caret to the definition of the item.\n\n\nYou can navigate back and forth using the traditional \nAlt + Arrow Left\n (or \nEscape\n) and \nAlt + Arrow Right\n key combos, or via the Navigation menu.\n\n\n\n\nThe \nNext Item\n and \nPrevious Item\n command allow you to jump to the similar item after or before the currently selected item. \n\n\nCross-references\n\n\nCross-references on an item allow the examination of items referencing it. Press the \nX\n key to visualize them.\n\n\nYou can jump to a cross-reference by double-clicking it.\n\n\n\n\nType Hierarchies\n\n\nUse the \nT\n key on a type item (such as a class or an interface) to visualize its ancestors and children. Double-click on a type item to jump to the item definition.\n\n\n\n\nRestructuring\n\n\nThe \nCreate Package\n and \nMove to Package\n actions offer powerful refactoring possibilities, especially useful in the case of large obfuscated binary files.\n\n\nIf the module supports it, users are able to:\n\n\n\n\nCreate artifical packages (aka, namespaces) using the \nK\n key.\n\n\nMove items, such as types, to existing or artificial packages using the \nL\n key.\n\n\n\n\nThe following screenshot is an example where the class \nAppHelp\n was moved from the \ncom.pnfsoftware.raasta\n package to a newly created package named \ncom.abc\n.\n\n\n\n\n\n\nWant to learn more?\n Have a look at \nour YouTube demo video\n that demonstrates advanced refactoring and automatic restructuring of a heavily obfuscated Android malware application.\n\n\n\n\nObject Overrides\n\n\nThe \nO\n key allows the examination of overrides, such as virtual method redefinitions in the case of object-oriented bytecode files.\n\n\n\n\nNote\n: As said above, keep in mind that plugins are allowed to attach the semantic they want to a given action. For instance, in the case of a document analysis plugin, the \nOverrides\n action may or may not be relevant. If it existed, it would certainly have a different meaning than \"method overrides\".\n\n\n\n\nRebasing Constants\n\n\nThis feature allows the selection of the radix used to render immediate constant integers. Press the \nB\n key repeatedly to cycle through the bases offered by the plugin.\n\n\nTypically, bases 8, 10, 16 are offered. Some plugins may offer additional bases such as base 2, or non-conventional representation modes, such as character-based immediate rendering.",
            "title": "Common Actions"
        },
        {
            "location": "/actions/index.html#common-actions",
            "text": "One principal intended use for JEB is the analysis of binary code. This section focuses on the basics of  code analysis and refactoring , such as:   renaming items such as methods or fields  changing the code structure by moving items to packages   commenting  navigating a code base via cross-references  viewing type hierarchies  etc.   In the RCP client, many interactions can be achieved via the  Action  and  Navigation  menus. Those actions are implemented by most JEB analysis modules that perform code disassembly.    Note : Other action groups such as  Native code actions  and  Debugging actions  are detailed in later sections.  Note : The examples in this section are based on the analysis of  Raasta.apk  using the Android DEX parser.  Keep in mind that features and behaviors of  Actions  depend on the module implementing and performing them.",
            "title": "Common Actions"
        },
        {
            "location": "/actions/index.html#renaming",
            "text": "An important requirement for analysts is the ability to rename code items such as types, methods and routines, fields and data items, packages, etc. consistently across a code base.   Position the caret on the item to be renamed  Hit the  N  key or select  Action, Rename  Enter the new name and press Enter    Tip:  Within the Rename dialog box, press Ctrl+Space to bring up your renaming history.",
            "title": "Renaming"
        },
        {
            "location": "/actions/index.html#commenting",
            "text": "Anywhere in the code, press the  /  (slash) key to add a comment. Comments are attached to addresses or items.",
            "title": "Commenting"
        },
        {
            "location": "/actions/index.html#navigating",
            "text": "Pressing the  Enter  key on an item or double-clicking it will bring the caret to the definition of the item.  You can navigate back and forth using the traditional  Alt + Arrow Left  (or  Escape ) and  Alt + Arrow Right  key combos, or via the Navigation menu.   The  Next Item  and  Previous Item  command allow you to jump to the similar item after or before the currently selected item.",
            "title": "Navigating"
        },
        {
            "location": "/actions/index.html#cross-references",
            "text": "Cross-references on an item allow the examination of items referencing it. Press the  X  key to visualize them.  You can jump to a cross-reference by double-clicking it.",
            "title": "Cross-references"
        },
        {
            "location": "/actions/index.html#type-hierarchies",
            "text": "Use the  T  key on a type item (such as a class or an interface) to visualize its ancestors and children. Double-click on a type item to jump to the item definition.",
            "title": "Type Hierarchies"
        },
        {
            "location": "/actions/index.html#restructuring",
            "text": "The  Create Package  and  Move to Package  actions offer powerful refactoring possibilities, especially useful in the case of large obfuscated binary files.  If the module supports it, users are able to:   Create artifical packages (aka, namespaces) using the  K  key.  Move items, such as types, to existing or artificial packages using the  L  key.   The following screenshot is an example where the class  AppHelp  was moved from the  com.pnfsoftware.raasta  package to a newly created package named  com.abc .    Want to learn more?  Have a look at  our YouTube demo video  that demonstrates advanced refactoring and automatic restructuring of a heavily obfuscated Android malware application.",
            "title": "Restructuring"
        },
        {
            "location": "/actions/index.html#object-overrides",
            "text": "The  O  key allows the examination of overrides, such as virtual method redefinitions in the case of object-oriented bytecode files.   Note : As said above, keep in mind that plugins are allowed to attach the semantic they want to a given action. For instance, in the case of a document analysis plugin, the  Overrides  action may or may not be relevant. If it existed, it would certainly have a different meaning than \"method overrides\".",
            "title": "Object Overrides"
        },
        {
            "location": "/actions/index.html#rebasing-constants",
            "text": "This feature allows the selection of the radix used to render immediate constant integers. Press the  B  key repeatedly to cycle through the bases offered by the plugin.  Typically, bases 8, 10, 16 are offered. Some plugins may offer additional bases such as base 2, or non-conventional representation modes, such as character-based immediate rendering.",
            "title": "Rebasing Constants"
        },
        {
            "location": "/views/index.html",
            "text": "Common Views\n\n\nTo visualize a unit, double-click on its node in the \nProject Explorer\n panel, or right-click and select \nOpen, View\n.\n\n\nThe \nview\n for a unit is a placeholder for one or more \nfragments\n, representing unit \ndocuments\n. For example, a DEX unit (which is the analysis result of an Android DEX file) is visually rendered by several fragments, including:\n\n\n\n\nA \nDescription\n static text view\n\n\nA \nHex Dump\n view\n\n\nAn \nAssembly\n interactive text view\n\n\nA \nStrings\n interactive table view\n\n\nA \nCode Hierarchy\n interactive tree view\n\n\n\n\n\n\nNote\n: Some types of documents provide addressing support. Addressing support is a necessary requirement to enable interactive actions such as navigation and cross-referencing, as will be discussed later.\n\n\n\n\nThe following sub-sections provide examples of common fragments and views encountered when analyzing binary files:\n\n\nDescription Documents\n\n\nThe \nDescription\n document is a standard buffer of text provided by all units. It contains a small body of text presenting various characteristics of the unit, including whether or not it contains children units.\n\n\n\n\nHex Dump Documents\n\n\nThe \nHex Dump\n document is a hexadecimal representation of the input artifact. This document can efficiently represent artifacts of a size up to 2^63 bytes.\n\n\nHelper widgets are provided for easy visualization of unpacked byte sequences.\n\n\n\n\nText Documents\n\n\nUnits commonly provide interactive text documents to represent their contents. Text documents are addressable. Those views can efficiently represent extremely large bodies of text - up to billions of lines if necessary.\n\n\nThe navigation bar, vertically positioned on the right-hand side of the document by default, allows navigating the document.\n\n\nExamples include: assembly documents, xml documents, decompiled code documents, etc.\n\n\n\n\n\n\nNavigation bar\n\n\nTODO: document the bar features.\n\n\nTable Documents\n\n\nUnits may provide table documents to represent their contents. Table documents are addressable.\n\n\n\n\nTree Documents\n\n\nUnits may provide tree documents to represent their contents. Tree documents are addressable.\n\n\nExample: Interactive Simple Tree: Code Hierarchy\n\n\nCode hierarchies are interactive trees that allow navigation to code items, such as methods or routines.\n\n\n\n\nExample: Static Table Tree: Digital Certificate Data\n\n\nParsed certificate can be represented as static table tree documents. For example, the APK module produces such documents. \n\n\n\n\nAnother example of a table tree (for which each node is a row within a table) is the global structure of a PDF document produced by the PDF plugin.\n\n\n\n\nMime-typed Documents\n\n\nA unit may issue mime-typed documents. It is up to front-end clients to implement rendering engines for some of those types. For example, the official RCP client render various image types.\n\n\n\n\nCustom Documents\n\n\nSpecialized units, such as debugger or native code units, offer access to specific data that does not fit in standard document categories. It is up to the front-end to render whatever is deemed necessary.\n\n\nFor example, the RCP client produces 6 or 7 specialized views to represent debugger units (such as breakpoints, threads, locals, memory, ..).\n\n\nSpecialized views\n are described in sections dealing with specialized units, eg \ndebuggers\n or \nnative disassemblers\n.",
            "title": "Common Views"
        },
        {
            "location": "/views/index.html#common-views",
            "text": "To visualize a unit, double-click on its node in the  Project Explorer  panel, or right-click and select  Open, View .  The  view  for a unit is a placeholder for one or more  fragments , representing unit  documents . For example, a DEX unit (which is the analysis result of an Android DEX file) is visually rendered by several fragments, including:   A  Description  static text view  A  Hex Dump  view  An  Assembly  interactive text view  A  Strings  interactive table view  A  Code Hierarchy  interactive tree view    Note : Some types of documents provide addressing support. Addressing support is a necessary requirement to enable interactive actions such as navigation and cross-referencing, as will be discussed later.   The following sub-sections provide examples of common fragments and views encountered when analyzing binary files:",
            "title": "Common Views"
        },
        {
            "location": "/views/index.html#description-documents",
            "text": "The  Description  document is a standard buffer of text provided by all units. It contains a small body of text presenting various characteristics of the unit, including whether or not it contains children units.",
            "title": "Description Documents"
        },
        {
            "location": "/views/index.html#hex-dump-documents",
            "text": "The  Hex Dump  document is a hexadecimal representation of the input artifact. This document can efficiently represent artifacts of a size up to 2^63 bytes.  Helper widgets are provided for easy visualization of unpacked byte sequences.",
            "title": "Hex Dump Documents"
        },
        {
            "location": "/views/index.html#text-documents",
            "text": "Units commonly provide interactive text documents to represent their contents. Text documents are addressable. Those views can efficiently represent extremely large bodies of text - up to billions of lines if necessary.  The navigation bar, vertically positioned on the right-hand side of the document by default, allows navigating the document.  Examples include: assembly documents, xml documents, decompiled code documents, etc.",
            "title": "Text Documents"
        },
        {
            "location": "/views/index.html#navigation-bar",
            "text": "TODO: document the bar features.",
            "title": "Navigation bar"
        },
        {
            "location": "/views/index.html#table-documents",
            "text": "Units may provide table documents to represent their contents. Table documents are addressable.",
            "title": "Table Documents"
        },
        {
            "location": "/views/index.html#tree-documents",
            "text": "Units may provide tree documents to represent their contents. Tree documents are addressable.",
            "title": "Tree Documents"
        },
        {
            "location": "/views/index.html#example-interactive-simple-tree-code-hierarchy",
            "text": "Code hierarchies are interactive trees that allow navigation to code items, such as methods or routines.",
            "title": "Example: Interactive Simple Tree: Code Hierarchy"
        },
        {
            "location": "/views/index.html#example-static-table-tree-digital-certificate-data",
            "text": "Parsed certificate can be represented as static table tree documents. For example, the APK module produces such documents.    Another example of a table tree (for which each node is a row within a table) is the global structure of a PDF document produced by the PDF plugin.",
            "title": "Example: Static Table Tree: Digital Certificate Data"
        },
        {
            "location": "/views/index.html#mime-typed-documents",
            "text": "A unit may issue mime-typed documents. It is up to front-end clients to implement rendering engines for some of those types. For example, the official RCP client render various image types.",
            "title": "Mime-typed Documents"
        },
        {
            "location": "/views/index.html#custom-documents",
            "text": "Specialized units, such as debugger or native code units, offer access to specific data that does not fit in standard document categories. It is up to the front-end to render whatever is deemed necessary.  For example, the RCP client produces 6 or 7 specialized views to represent debugger units (such as breakpoints, threads, locals, memory, ..).  Specialized views  are described in sections dealing with specialized units, eg  debuggers  or  native disassemblers .",
            "title": "Custom Documents"
        },
        {
            "location": "/decompiling/index.html",
            "text": "Decompiling Code\n\n\nDecompiler are special modules that work on units as input instead of artifacts. They produce units as well, representing portions of decompiled source code.\n\n\nThe following picture shows a child decompiler unit, as well as a suite of decompiled classes units.\n\n\n \n\n\n\n\nNote:\n The Android DEX has a companion DEX decompiler module. Other decompilation modules for native code (x86, ARM, etc.) will be released with JEB 2.3.x.\n\n\n\n\nHow to Decompile\n\n\n\n\nWhile in the assembly view, position your caret on the area of code you would like to decompile.\n\n\nHit the \nTab\n or \nQ\n key to decompile code\n\n\nIf a decompiler unit can be created for the current code unit, a new decompiled code unit will be created\n\n\nThe decompiled code unit will receive focus and the caret positioned on the area of code that most closely corresponds to the low-level bytecode or machine code\n\n\n\n\n  \n\n\nBack to the Assembly\n\n\nConversely, you can go back to the assembly from a decompiled view by using the \nTab\n or \nQ\n key. \n\n\nManaging Views\n\n\nBy default, a view representing a portion of decompiled code (eg, a class) will be replaced by the next class being decompiled. This default behavior is to avoid cluttering the workspace with tens of views representing various decompiled artifacts. However, if you would like to open every piece of decompiled code in a separate view, you may do so by checking the \nNavigation, do not replace Views\n menu option.\n\n\n\n\nActions and Interactivity\n\n\nGenerally, when it comes to interactity, decompilation plugins proxy requests to their corresponding parent code unit. That means that the actions set offered is essentially the same. The consistency between views is maintained.",
            "title": "Decompiling"
        },
        {
            "location": "/decompiling/index.html#decompiling-code",
            "text": "Decompiler are special modules that work on units as input instead of artifacts. They produce units as well, representing portions of decompiled source code.  The following picture shows a child decompiler unit, as well as a suite of decompiled classes units.      Note:  The Android DEX has a companion DEX decompiler module. Other decompilation modules for native code (x86, ARM, etc.) will be released with JEB 2.3.x.",
            "title": "Decompiling Code"
        },
        {
            "location": "/decompiling/index.html#how-to-decompile",
            "text": "While in the assembly view, position your caret on the area of code you would like to decompile.  Hit the  Tab  or  Q  key to decompile code  If a decompiler unit can be created for the current code unit, a new decompiled code unit will be created  The decompiled code unit will receive focus and the caret positioned on the area of code that most closely corresponds to the low-level bytecode or machine code",
            "title": "How to Decompile"
        },
        {
            "location": "/decompiling/index.html#back-to-the-assembly",
            "text": "Conversely, you can go back to the assembly from a decompiled view by using the  Tab  or  Q  key.",
            "title": "Back to the Assembly"
        },
        {
            "location": "/decompiling/index.html#managing-views",
            "text": "By default, a view representing a portion of decompiled code (eg, a class) will be replaced by the next class being decompiled. This default behavior is to avoid cluttering the workspace with tens of views representing various decompiled artifacts. However, if you would like to open every piece of decompiled code in a separate view, you may do so by checking the  Navigation, do not replace Views  menu option.",
            "title": "Managing Views"
        },
        {
            "location": "/decompiling/index.html#actions-and-interactivity",
            "text": "Generally, when it comes to interactity, decompilation plugins proxy requests to their corresponding parent code unit. That means that the actions set offered is essentially the same. The consistency between views is maintained.",
            "title": "Actions and Interactivity"
        },
        {
            "location": "/debugging/index.html",
            "text": "Debugging\n\n\nDebuggers are special modules that attach to existing code units. They do not produce additional units; instead, they provide \nspecialized actions\n, accessible graphically via the \nDebugger\n menu in the RCP client.\n\n\nThe following picture shows two debugger units connected to an Android app.\n\n\n\n\n\n\nNote to developers\n: debugger modules offer a rich API. UI clients can only reflect those functionality partly. Visit the \nResources\n sub-section for more information on how to use the debuggers API to perform advanced dynamic analysis of applications.\n\n\n\n\nAvailability\n\n\nCurrently, JEB ships with debuggers for:\n\n\n\n\nAndroid DEX bytecode: the debugger is a custom JDWP client implementation\n\n\nx86/x86-64, ARM/ARM64, and MIPS: the debuggers are custom GDB client implementations\n\n\n\n\nAs of JEB 2.3.0, only Android applications (bytecode and native code) have debugging support.\n\n\n\n\nNote\n: Additional debuggers will be released with JEB 2.3.x maintenance updates, including support for Windows and Linux executables debugging.\n\n\n\n\nAttaching to a Target\n\n\n\n\nOpen a code view representing the code unit to be debugged.\n\n\nExecute *Debugger/Attach\"\n\n\nSelect the target machine and target process\n\n\nClick \nAttach\n\n\n\n\n\n\nOne or more debugger unit(s) will be created, depending on your target application.\n\n\nViews\n\n\nThe RCP client will also open automatically open views that represent the debugger units. Those views are:\n\n\n\n\nThreads\n\n\nBreakpoints\n\n\nLocal variables and registers\n\n\nMemory and live disassembly (if applicable)\n\n\nCurrent stack (if applicable)\n\n\nLog view\n\n\n\n\n\n\nYou may want to switch to a custom layout to better accommodate those additional views. The above pictures shows an on-going debugging session of an Android app. A custom layout is used:\n\n\n\n\nthe bytecode debugger views are in the top-right hand quadrant\n\n\nthe process code debugger views are in the bottom-right hand quadrant\n\n\n\n\nA breakpoint can also be seen, as well as the about-to-be-executed line of code.\n\n\nBasic Commands\n\n\nThe basic commands are accessible from the \nDebugger\n menu.\n\n\n\n\nDetach from or restart the debugging session\n\n\nPause, resume, or terminate the target\n\n\nSuspend or resume threads\n\n\nSet breakpoints\n\n\nStep execution (into, over, or out of a routine)\n\n\netc.\n\n\n\n\nThe live values of variables and registers can also be examining by hovering over an item representing them.\n\n\n\n\nMore\n: a detailed overview of basic debugging capabilities, specifically for Android app debugging, can be found on our \nblog\n. \n\n\n\n\nAdvanced Commands\n\n\nAdvanced debugging commands can be used via the \nConsole\n view. This view is linked to \ncommand interpreters\n offered by the currently focused unit. Debuggers offer command interpreter to perform advanced tasks such as:\n\n\n\n\nSearching patterns in memory\n\n\nExamining objects\n\n\nCreating objects or invoking methods\n\n\nCustom tasks specific to a given debugger that cannot be generically represented by the RCP client\n\n\n\n\nThe screenshot below shows the expanded \nConsole\n view with an interpreter connected to the Dalvik Bytecode debugger:\n\n\n\n\n\n\nMore\n: a detailed overview of the interpreters' features can be found on our \nblog\n.\n\n\n\n\nResources\n\n\n\n\nDebugger Tutorial, part 1 - Android: \nAn Introduction to JEB Android Debuggers\n\n\nDebugger Tutorial, part 2 - Interpreter: \nAdvanced Debugger Usage via the Interpreter\n\n\nDebugger Tutorial, part 3 - Automation: \nCrypto Monitoring with the Android Debuggers API\n\n\n\n\nAlso consult the \nReference API Documentation\n.",
            "title": "Debugging"
        },
        {
            "location": "/debugging/index.html#debugging",
            "text": "Debuggers are special modules that attach to existing code units. They do not produce additional units; instead, they provide  specialized actions , accessible graphically via the  Debugger  menu in the RCP client.  The following picture shows two debugger units connected to an Android app.    Note to developers : debugger modules offer a rich API. UI clients can only reflect those functionality partly. Visit the  Resources  sub-section for more information on how to use the debuggers API to perform advanced dynamic analysis of applications.",
            "title": "Debugging"
        },
        {
            "location": "/debugging/index.html#availability",
            "text": "Currently, JEB ships with debuggers for:   Android DEX bytecode: the debugger is a custom JDWP client implementation  x86/x86-64, ARM/ARM64, and MIPS: the debuggers are custom GDB client implementations   As of JEB 2.3.0, only Android applications (bytecode and native code) have debugging support.   Note : Additional debuggers will be released with JEB 2.3.x maintenance updates, including support for Windows and Linux executables debugging.",
            "title": "Availability"
        },
        {
            "location": "/debugging/index.html#attaching-to-a-target",
            "text": "Open a code view representing the code unit to be debugged.  Execute *Debugger/Attach\"  Select the target machine and target process  Click  Attach    One or more debugger unit(s) will be created, depending on your target application.",
            "title": "Attaching to a Target"
        },
        {
            "location": "/debugging/index.html#views",
            "text": "The RCP client will also open automatically open views that represent the debugger units. Those views are:   Threads  Breakpoints  Local variables and registers  Memory and live disassembly (if applicable)  Current stack (if applicable)  Log view    You may want to switch to a custom layout to better accommodate those additional views. The above pictures shows an on-going debugging session of an Android app. A custom layout is used:   the bytecode debugger views are in the top-right hand quadrant  the process code debugger views are in the bottom-right hand quadrant   A breakpoint can also be seen, as well as the about-to-be-executed line of code.",
            "title": "Views"
        },
        {
            "location": "/debugging/index.html#basic-commands",
            "text": "The basic commands are accessible from the  Debugger  menu.   Detach from or restart the debugging session  Pause, resume, or terminate the target  Suspend or resume threads  Set breakpoints  Step execution (into, over, or out of a routine)  etc.   The live values of variables and registers can also be examining by hovering over an item representing them.   More : a detailed overview of basic debugging capabilities, specifically for Android app debugging, can be found on our  blog .",
            "title": "Basic Commands"
        },
        {
            "location": "/debugging/index.html#advanced-commands",
            "text": "Advanced debugging commands can be used via the  Console  view. This view is linked to  command interpreters  offered by the currently focused unit. Debuggers offer command interpreter to perform advanced tasks such as:   Searching patterns in memory  Examining objects  Creating objects or invoking methods  Custom tasks specific to a given debugger that cannot be generically represented by the RCP client   The screenshot below shows the expanded  Console  view with an interpreter connected to the Dalvik Bytecode debugger:    More : a detailed overview of the interpreters' features can be found on our  blog .",
            "title": "Advanced Commands"
        },
        {
            "location": "/debugging/index.html#resources",
            "text": "Debugger Tutorial, part 1 - Android:  An Introduction to JEB Android Debuggers  Debugger Tutorial, part 2 - Interpreter:  Advanced Debugger Usage via the Interpreter  Debugger Tutorial, part 3 - Automation:  Crypto Monitoring with the Android Debuggers API   Also consult the  Reference API Documentation .",
            "title": "Resources"
        },
        {
            "location": "/native/index.html",
            "text": "Native Code Actions\n\n\nNative code actions are actions specific to native code units, which are highly-interactive.\n\n\nNative code actions are grouped in the \nNative\n menu:\n\n\n\n\n\n\nSection is to be completed.",
            "title": "Native Code Actions"
        },
        {
            "location": "/native/index.html#native-code-actions",
            "text": "Native code actions are actions specific to native code units, which are highly-interactive.  Native code actions are grouped in the  Native  menu:    Section is to be completed.",
            "title": "Native Code Actions"
        },
        {
            "location": "/misc/index.html",
            "text": "Miscellaneous\n\n\nThis section describes miscellaneous features offered by the RCP client.\n\n\nSaving and Loading\n\n\nA JEB project can be persisted to a file on disk called a \nJEB Database (version 2)\n file. Such files have a \n.jdb2\n extension.\n\n\nJDB2 files can be shared among users, and reloaded later on. They can grow significantly larger than the original artifact(s), as they contain the analysis results for all - or most of all, see below - units in your project. They are \nencrypted\n and \ncompressed\n.\n\n\nMake sure to load a JDB2 with a version of JEB equal or newer than the one that generated that JDB2.\n\n\n\n\nNote\n: Each module determines whether or not persistence of the units they produce is supported. All official non-beta modules support persistence.\n\n\nCaution\n: The analysis of large artifacts, yielding potentially hundreds or thousands of units, can translate into very large JDB2. \n\n\n\n\nUnit Notifications\n\n\nNotifications\n are generated by modules when they encounter areas of interest during analysis of their input data. The menu entry \nFile, Unit notifications\n allows the user to view notificatins for all units produced in the currently opened project.\n\n\nIn the example below, the Android DEX plugin has generated a notification indicating that the analyzed Android app contained multiple DEX files, and that those were merged successfuly:\n\n\n\n\nNotifications are generated at the discretion of the analysis modules. They can be classified in one of nine levels:\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAREA_OF_INTEREST\n\n\nA generic type to signify an area of interest within a unit.\n\n\n\n\n\n\nCORRUPTION\n\n\nInput corruption has been detected.\n\n\n\n\n\n\nDEPRECATED_FEATURE\n\n\nThe unit has detected features that have been deprecated.\n\n\n\n\n\n\nERROR\n\n\nA generic type to signify an error in the unit.\n\n\n\n\n\n\nINFO\n\n\nA generic type similar to AREA_OF_INTEREST.\n\n\n\n\n\n\nMALICIOUS\n\n\nThe intent is malicious.\n\n\n\n\n\n\nPOTENTIALLY_HARMFUL\n\n\nThis type indicates usage of a feature not recommended by guidelines due to its potential dangerousness.\n\n\n\n\n\n\nUNSUPPORTED_FEATURE\n\n\nSome input cannot be parsed because of a limitation within the unit itself.\n\n\n\n\n\n\nWARNING\n\n\nA generic type to signify a warning in the unit.\n\n\n\n\n\n\n\n\n\n\nNote\n: See this \nreference page\n for additional details.\n\n\n\n\nExporting Output\n\n\nThe RCP client offers a special \"Export\" command for Decompiler plugins. This command allows exporting of one, some, or all of the decompiled code that can be generated by a given decompiler (methods, classes, etc.).\n\n\nThis command is accessible via the \nFile, Export\n menu entry. Make sure to focus a code view or a decompiled code view before attempting to run this command.\n\n\n\n\nProject Properties\n\n\nThe properties of a project can be examined by right-clicking the project node in the \nProject Explorer\n view, via the \nFile\n menu, or by using the \nAlt+Enter\n key combo when the project node is selected.\n\n\n\n\nThe name is customizable. The default name is always derived from the primary artifact, with a \nJDB2\n extension. This extension stands for \"JEB Database Version 2\", and represent a serialized version of your project which users can save and load on their JEB version 2 software.\n\n\nThe creation and modification timestamps are read-only.\n\n\nThe user-notes are obviously writeable and saved with the JDB2.\n\n\n\n\n\n\nArtifact Properties\n\n\nSimilarly to Project properties, the properties of an artifact can be examined by right-clicking the artifact node in the \nProject Explorer\n view, via the \nFile\n menu, or by using the \nAlt+Enter\n key combo when the artifact node is selected.\n\n\n\n\nUnit Properties\n\n\nSimilar to Project and Artifact properties, the properties of a unit can be examined by right-clicking the corresponding unit node in the \nProject Explorer\n view, via the \nFile\n menu, or by using the \nAlt+Enter\n key combo when the unit node is selected.\n\n\n\n\nThe unit name is customizable, however, \nwe recommend users to not change unit names\n.\n\n\nThe unit type corresponds to the module type that created the unit (in this example, 'apk')\n\n\nThe creation timestamp is the time at which the unit was created from its parent artifact or unit\n\n\nThe status field indicates potential problems: \nN/A\n means the unit was processed properly, and its contents can be examined; other string messages can be reported by modules to indicate processing error, or simply, lack of processing in the case of lazy processing.\n\n\n\n\n\n\nListing Parsers\n\n\nThe full list of \ninput processor plugins\n (whose term was simplified to \nparsers\n in the UI) loaded within your JEB instance context can be seen by running the \nFile, Engines, Parsers\n command.\n\n\n\n\nParsers can be selectively disabled if you would like JEB. For example, if you would like JEB to not process ZIP files as such (ie, treat them as plain binary files), you may disable the zip parser.\n\n\n\n\nNote\n: technically speaking, \nparsers\n are JEB plugins that implement the \nIUnitIdentifier\n interface. Refer to the \"Developing with JEB\" section of this guide for more information.\n\n\n\n\nAdding Artififacts\n\n\nCommonly, most projects will contain a single artifact file, such as a binary executable or an application file. However, you may add as many artifacts as you want to a project \n\n\nSelect the menu entry \nFile, Add an Artifact\n to add an artifact to an existing project. The newly added artifact will be processed, and added to the current project tree:\n\n\n\n\nReparsing Data\n\n\nThis advanced feature is available by right-clicking a unit in the Project Explorer view, and selecting \nParse at...\n:\n\n\n\n\nReparsing allows a user to (re)parse a unit or parts of a unit by specifying explicitly what the input data should be parsed as.\n\n\nFor instance, you may have input data identified as XML data, and initially parsed as such - therefore yielding an XML unit. However, you may discover that this XML data contains bytes that would correspond to a ZIP file (eg, starting with \nPK...\n). By reparsing the XML data at the given ZIP header offset using the ZIP module, you ask JEB to process that data as ZIP and create a ZIP unit out of it:\n\n\n\n\nReparsing can be helpful when dealing with complicated, obfuscated, or multi-layered files.",
            "title": "Miscellaneous"
        },
        {
            "location": "/misc/index.html#miscellaneous",
            "text": "This section describes miscellaneous features offered by the RCP client.",
            "title": "Miscellaneous"
        },
        {
            "location": "/misc/index.html#saving-and-loading",
            "text": "A JEB project can be persisted to a file on disk called a  JEB Database (version 2)  file. Such files have a  .jdb2  extension.  JDB2 files can be shared among users, and reloaded later on. They can grow significantly larger than the original artifact(s), as they contain the analysis results for all - or most of all, see below - units in your project. They are  encrypted  and  compressed .  Make sure to load a JDB2 with a version of JEB equal or newer than the one that generated that JDB2.   Note : Each module determines whether or not persistence of the units they produce is supported. All official non-beta modules support persistence.  Caution : The analysis of large artifacts, yielding potentially hundreds or thousands of units, can translate into very large JDB2.",
            "title": "Saving and Loading"
        },
        {
            "location": "/misc/index.html#unit-notifications",
            "text": "Notifications  are generated by modules when they encounter areas of interest during analysis of their input data. The menu entry  File, Unit notifications  allows the user to view notificatins for all units produced in the currently opened project.  In the example below, the Android DEX plugin has generated a notification indicating that the analyzed Android app contained multiple DEX files, and that those were merged successfuly:   Notifications are generated at the discretion of the analysis modules. They can be classified in one of nine levels:     Type  Description      AREA_OF_INTEREST  A generic type to signify an area of interest within a unit.    CORRUPTION  Input corruption has been detected.    DEPRECATED_FEATURE  The unit has detected features that have been deprecated.    ERROR  A generic type to signify an error in the unit.    INFO  A generic type similar to AREA_OF_INTEREST.    MALICIOUS  The intent is malicious.    POTENTIALLY_HARMFUL  This type indicates usage of a feature not recommended by guidelines due to its potential dangerousness.    UNSUPPORTED_FEATURE  Some input cannot be parsed because of a limitation within the unit itself.    WARNING  A generic type to signify a warning in the unit.      Note : See this  reference page  for additional details.",
            "title": "Unit Notifications"
        },
        {
            "location": "/misc/index.html#exporting-output",
            "text": "The RCP client offers a special \"Export\" command for Decompiler plugins. This command allows exporting of one, some, or all of the decompiled code that can be generated by a given decompiler (methods, classes, etc.).  This command is accessible via the  File, Export  menu entry. Make sure to focus a code view or a decompiled code view before attempting to run this command.",
            "title": "Exporting Output"
        },
        {
            "location": "/misc/index.html#project-properties",
            "text": "The properties of a project can be examined by right-clicking the project node in the  Project Explorer  view, via the  File  menu, or by using the  Alt+Enter  key combo when the project node is selected.   The name is customizable. The default name is always derived from the primary artifact, with a  JDB2  extension. This extension stands for \"JEB Database Version 2\", and represent a serialized version of your project which users can save and load on their JEB version 2 software.  The creation and modification timestamps are read-only.  The user-notes are obviously writeable and saved with the JDB2.",
            "title": "Project Properties"
        },
        {
            "location": "/misc/index.html#artifact-properties",
            "text": "Similarly to Project properties, the properties of an artifact can be examined by right-clicking the artifact node in the  Project Explorer  view, via the  File  menu, or by using the  Alt+Enter  key combo when the artifact node is selected.",
            "title": "Artifact Properties"
        },
        {
            "location": "/misc/index.html#unit-properties",
            "text": "Similar to Project and Artifact properties, the properties of a unit can be examined by right-clicking the corresponding unit node in the  Project Explorer  view, via the  File  menu, or by using the  Alt+Enter  key combo when the unit node is selected.   The unit name is customizable, however,  we recommend users to not change unit names .  The unit type corresponds to the module type that created the unit (in this example, 'apk')  The creation timestamp is the time at which the unit was created from its parent artifact or unit  The status field indicates potential problems:  N/A  means the unit was processed properly, and its contents can be examined; other string messages can be reported by modules to indicate processing error, or simply, lack of processing in the case of lazy processing.",
            "title": "Unit Properties"
        },
        {
            "location": "/misc/index.html#listing-parsers",
            "text": "The full list of  input processor plugins  (whose term was simplified to  parsers  in the UI) loaded within your JEB instance context can be seen by running the  File, Engines, Parsers  command.   Parsers can be selectively disabled if you would like JEB. For example, if you would like JEB to not process ZIP files as such (ie, treat them as plain binary files), you may disable the zip parser.   Note : technically speaking,  parsers  are JEB plugins that implement the  IUnitIdentifier  interface. Refer to the \"Developing with JEB\" section of this guide for more information.",
            "title": "Listing Parsers"
        },
        {
            "location": "/misc/index.html#adding-artififacts",
            "text": "Commonly, most projects will contain a single artifact file, such as a binary executable or an application file. However, you may add as many artifacts as you want to a project   Select the menu entry  File, Add an Artifact  to add an artifact to an existing project. The newly added artifact will be processed, and added to the current project tree:",
            "title": "Adding Artififacts"
        },
        {
            "location": "/misc/index.html#reparsing-data",
            "text": "This advanced feature is available by right-clicking a unit in the Project Explorer view, and selecting  Parse at... :   Reparsing allows a user to (re)parse a unit or parts of a unit by specifying explicitly what the input data should be parsed as.  For instance, you may have input data identified as XML data, and initially parsed as such - therefore yielding an XML unit. However, you may discover that this XML data contains bytes that would correspond to a ZIP file (eg, starting with  PK... ). By reparsing the XML data at the given ZIP header offset using the ZIP module, you ask JEB to process that data as ZIP and create a ZIP unit out of it:   Reparsing can be helpful when dealing with complicated, obfuscated, or multi-layered files.",
            "title": "Reparsing Data"
        },
        {
            "location": "/dev/introducing-jeb-extensions/index.html",
            "text": "Introducing JEB Extensions\n\n\nJEB offers a rich API that can be used to develop:\n\n\n\n\nFront-end clients\n, such as:\n\n\nThe official \nRCP client\n\n\nHeadless clients for automation pipelines\n\n\n\n\n\n\nPlugins\n (aka \nback-end modules\n):\n\n\nProcessor plugins\n such as disassemblers, decompilers, debuggers, or any other type of analyzer\n\n\nMany processor plugins fall in the category of \nparsers\n and are sometimes referred as such\n\n\n\n\n\n\nEngines plugins\n such as second-pass code analyzers, working on results produced by other plugins, or helpers\n\n\n\n\n\n\nScripts\n:\n\n\nPython scripts for automating simple tasks\n\n\nPython scripts that can interact with graphical clients that implement the UI-API (the RCP client does)\n\n\n\n\n\n\n\n\n\n\nNote:\n the \nDeveloping with JEB\n area of this guide is superseding our \nDeveloper Portal\n. This is a work-in-progress as old pages are being ported over, and new contents is being added.\n\n\n\n\nCapabilities\n\n\nOnly professional licenses offer full API access. However, all licenses allow script execution from within the RCP client:\n\n\n\n\n\n\n\n\nLicenses Type\n\n\nRCP client\n\n\nOther Clients (incl. command-line)\n\n\n\n\n\n\n\n\n\n\nBasic\n\n\nUI scripts\n\n\nno\n\n\n\n\n\n\nPro\n\n\nUI scripts + plugins\n\n\nscripts + plugins\n\n\n\n\n\n\n\n\nHigh-level Architecture\n\n\nGrasping the high-level concepts of how pieces fit together within JEB will make you a more efficient extensions developer.\n\n\nAt the highest-level, JEB is separated into back-end and front-end components:\n\n\n\n\nThe back-end components are responsible for processing input artifacts. They provide an execution environment for native and third-party plugins, including input artifact processor plugins, such as file parsers.\n\n\nThe front-end components are responsible for processing input commands and rendering back-end results. A variety of front-ends may be created using the API exposed by the back-end.\n\n\n\n\n\n\nNote:\n As said earlier, all JEB distributions ship with the RCP client front-end that runs on all major desktop operating systems.\n\n\n\n\nThe diagram below shows the relationship between back-end and front-end components:\n\n\n\n\nDepending on their license type, users may be able to develop third-party plugins and instruct the back-end to load them. This enables power users to craft input processors that cater to their specific needs (eg, a disassembler for an exotic or virtual CPU).\n\n\nYou may verify your API usage capabilities by starting JEB with the \n-c --license\n command line flag.\n\n\nAPI\n\n\nThe JEB 2.x Application Programming Interface offers power-users ways to:\n\n\n\n\nwrite clients such as command-line processors (headless)\n\n\nwrite extensions, from simple scripts in \nPython\n to advanced analysis modules in \nJava\n\n\n\n\nThe JEB API reference documentation is \navailable online\n as well as offline, within your JEB software package (file \ndoc/apidoc.zip\n).\n\n\nA exhaustive discussion of the API components is outside the scope of this guide.\n\n\n\n\nScripts vs Plugins\n\n\n\n\nScripts...\n\n\nImplement \nIScript\n\n\nAre called by users to achieve small tasks\n\n\nExample: modify some code, navigate somewhere, display some info, etc.\n\n\n\n\n\n\nHave to to be written in Python (and are run within a Jython VM)\n\n\nIdeal for rapid development and prototyping\n\n\n\n\n\n\nAre executed by JEB on-demand\n\n\nIn UI client, can be executed via the \nFile\n menu\n\n\n\n\n\n\n\n\n\n\nPlugins...\n\n\nImplement \nIPlugin\n (\nIUnitIdentifier\n for processor plugins, \nIEnginesPlugin\n for engines plugins)\n\n\nAre designed to process input (for processor plugins) or do other tasks (for engines plugins)\n\n\nExample: disassemble or decompile code, do complex file parsing, etc.\n\n\n\n\n\n\nMust be written in Java\n\n\nIdeal for complex, large code bases\n\n\n\n\n\n\nAre loaded by JEB at start-up time\n\n\nList of loaded plugins can be seen in the \nFile\n menu\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFuture\n: we may allow plugins to be written in Python soon, stay tuned!\n\n\n\n\nExecuting Scripts\n\n\n\n\nNote\n: All versions of JEB can execute \nclient scripts\n inside the RCP client.\n\n\n\n\nScripts \nshould\n be dropped in your \nscripts/\n directory (or any other directory specified in your \n.ScriptsFolder\n \nclient option\n).\nUse the \nFile, Script, Run Script...\n menu command to execute a script. The last run script can be executed again by pressing the \nF2\n key.\n\n\n\n\n\n\nClient scripts are written in Python, and are executed within a \nJython\n (a Java implementation of the Python VM)\n\n\nYou will need to drop a copy of the Jython JAR runtime in your JEB \nscripts/\n in order to execute scripts\n\n\nScripts, like any extension, use the JEB API. Visit the reference documentation for details.\n\n\nClient scripts executed inside the RCP client also have access to the \nUI-API\n (package \ncom.pnfsoftware.jeb.client.ui\n). Classes of the UI-API allow graphical manipulation of views, fragments, items, etc. (This sub-API is accessible only to clients that implement it; the RCP client does.)\n\n\n\n\nYou will find a large collection of sample scripts on our \npublic Github repository\n.\n\n\nExecuting Engines Plugins\n\n\nAll third-party plugins must be dropped in your \ncoreplugins/\n directory (or any other directory specified in your \n.PluginsFolder\n \nback-end option\n). Use the \nFile, Engines, Execute, ...\n menu command to execute an \nengines plugin\n.\n\n\n\n\nNote\n: technically speaking, \nengines plugins\n are JEB plugins that implement the \nIEnginesPlugin\n interface.\n\n\n\n\nThe full list of \nengines plugins\n loaded within your JEB instance context can be seen by running the \nFile, Engines, Plugins\n command. (You may double-click a plugin to execute it.)\n\n\n\n\nA collection of open-source plugins can be found on our \npublic Github repository\n.",
            "title": "Introducing JEB Extensions"
        },
        {
            "location": "/dev/introducing-jeb-extensions/index.html#introducing-jeb-extensions",
            "text": "JEB offers a rich API that can be used to develop:   Front-end clients , such as:  The official  RCP client  Headless clients for automation pipelines    Plugins  (aka  back-end modules ):  Processor plugins  such as disassemblers, decompilers, debuggers, or any other type of analyzer  Many processor plugins fall in the category of  parsers  and are sometimes referred as such    Engines plugins  such as second-pass code analyzers, working on results produced by other plugins, or helpers    Scripts :  Python scripts for automating simple tasks  Python scripts that can interact with graphical clients that implement the UI-API (the RCP client does)      Note:  the  Developing with JEB  area of this guide is superseding our  Developer Portal . This is a work-in-progress as old pages are being ported over, and new contents is being added.",
            "title": "Introducing JEB Extensions"
        },
        {
            "location": "/dev/introducing-jeb-extensions/index.html#capabilities",
            "text": "Only professional licenses offer full API access. However, all licenses allow script execution from within the RCP client:     Licenses Type  RCP client  Other Clients (incl. command-line)      Basic  UI scripts  no    Pro  UI scripts + plugins  scripts + plugins",
            "title": "Capabilities"
        },
        {
            "location": "/dev/introducing-jeb-extensions/index.html#high-level-architecture",
            "text": "Grasping the high-level concepts of how pieces fit together within JEB will make you a more efficient extensions developer.  At the highest-level, JEB is separated into back-end and front-end components:   The back-end components are responsible for processing input artifacts. They provide an execution environment for native and third-party plugins, including input artifact processor plugins, such as file parsers.  The front-end components are responsible for processing input commands and rendering back-end results. A variety of front-ends may be created using the API exposed by the back-end.    Note:  As said earlier, all JEB distributions ship with the RCP client front-end that runs on all major desktop operating systems.   The diagram below shows the relationship between back-end and front-end components:   Depending on their license type, users may be able to develop third-party plugins and instruct the back-end to load them. This enables power users to craft input processors that cater to their specific needs (eg, a disassembler for an exotic or virtual CPU).  You may verify your API usage capabilities by starting JEB with the  -c --license  command line flag.",
            "title": "High-level Architecture"
        },
        {
            "location": "/dev/introducing-jeb-extensions/index.html#api",
            "text": "The JEB 2.x Application Programming Interface offers power-users ways to:   write clients such as command-line processors (headless)  write extensions, from simple scripts in  Python  to advanced analysis modules in  Java   The JEB API reference documentation is  available online  as well as offline, within your JEB software package (file  doc/apidoc.zip ).  A exhaustive discussion of the API components is outside the scope of this guide.",
            "title": "API"
        },
        {
            "location": "/dev/introducing-jeb-extensions/index.html#scripts-vs-plugins",
            "text": "Scripts...  Implement  IScript  Are called by users to achieve small tasks  Example: modify some code, navigate somewhere, display some info, etc.    Have to to be written in Python (and are run within a Jython VM)  Ideal for rapid development and prototyping    Are executed by JEB on-demand  In UI client, can be executed via the  File  menu      Plugins...  Implement  IPlugin  ( IUnitIdentifier  for processor plugins,  IEnginesPlugin  for engines plugins)  Are designed to process input (for processor plugins) or do other tasks (for engines plugins)  Example: disassemble or decompile code, do complex file parsing, etc.    Must be written in Java  Ideal for complex, large code bases    Are loaded by JEB at start-up time  List of loaded plugins can be seen in the  File  menu        Future : we may allow plugins to be written in Python soon, stay tuned!",
            "title": "Scripts vs Plugins"
        },
        {
            "location": "/dev/introducing-jeb-extensions/index.html#executing-scripts",
            "text": "Note : All versions of JEB can execute  client scripts  inside the RCP client.   Scripts  should  be dropped in your  scripts/  directory (or any other directory specified in your  .ScriptsFolder   client option ).\nUse the  File, Script, Run Script...  menu command to execute a script. The last run script can be executed again by pressing the  F2  key.    Client scripts are written in Python, and are executed within a  Jython  (a Java implementation of the Python VM)  You will need to drop a copy of the Jython JAR runtime in your JEB  scripts/  in order to execute scripts  Scripts, like any extension, use the JEB API. Visit the reference documentation for details.  Client scripts executed inside the RCP client also have access to the  UI-API  (package  com.pnfsoftware.jeb.client.ui ). Classes of the UI-API allow graphical manipulation of views, fragments, items, etc. (This sub-API is accessible only to clients that implement it; the RCP client does.)   You will find a large collection of sample scripts on our  public Github repository .",
            "title": "Executing Scripts"
        },
        {
            "location": "/dev/introducing-jeb-extensions/index.html#executing-engines-plugins",
            "text": "All third-party plugins must be dropped in your  coreplugins/  directory (or any other directory specified in your  .PluginsFolder   back-end option ). Use the  File, Engines, Execute, ...  menu command to execute an  engines plugin .   Note : technically speaking,  engines plugins  are JEB plugins that implement the  IEnginesPlugin  interface.   The full list of  engines plugins  loaded within your JEB instance context can be seen by running the  File, Engines, Plugins  command. (You may double-click a plugin to execute it.)   A collection of open-source plugins can be found on our  public Github repository .",
            "title": "Executing Engines Plugins"
        },
        {
            "location": "/dev/writing-client-scripts/index.html",
            "text": "Writing Client Scripts\n\n\nAll JEB builds permit running \nscripts\n:\n\n\n\n\nScripts are meant to execute small, light-weight actions \n\n\nThey can be written using the Python 2.5 or 2.7 syntax and features, and are executed by a \nJython VM\n\n\n\n\nPrerequisite\n\n\nA \nJython stand-alone package\n is required to run scripts.\n\n\nDownload either \nJython 2.7 Standalone\n (newer, slower to load) or \nJython 2.5 Standalone\n (older and slimmer, faster to load) and drop it in your JEB \nscripts/\n sub-directory.\n\n\nFeatures\n\n\nScripts can:\n\n\n\n\nuse the standard \nJEB API\n\n\nuse the \nClient API package\n\n\nif run within a client that implements the UI-API, use the \nJEB UI Client API\n\n\n\n\nA client script implements the \nIScript\n interface. Upon execution, the script \nrun()\n entry-point method is provided an \nIClientContext\n or derived object, such as an \nIGraphicalClientContext\n for UI clients, such as the official RCP desktop client.\n\n\nA Simple Script\n\n\nHere is the simplest of all scripts:\n\n\nfrom com.pnfsoftware.jeb.client.api import IScript\n\nclass JEB2SampleScript(IScript):\n  def run(self, ctx):\n    print('Hello, JEB version %s' % ctx.getSoftwareVersion())\n    print('- Arguments: %s' % ctx.getArguments())\n    print('- Base directory: %s' % ctx.getBaseDirectory())\n\n\n\n\nWithin the official desktop client, scripts can be executed via the \nFile, Scripts\n menu item.\n\n\nRemember that heavy-lifting operations (such as parsing or background event-driven tasks) should be implemented by back-end plugins in Java.\n\n\nMore scripts\n\n\nCheck out our \nGitHub repository for more sample scripts\n.",
            "title": "Writing Client Scripts"
        },
        {
            "location": "/dev/writing-client-scripts/index.html#writing-client-scripts",
            "text": "All JEB builds permit running  scripts :   Scripts are meant to execute small, light-weight actions   They can be written using the Python 2.5 or 2.7 syntax and features, and are executed by a  Jython VM",
            "title": "Writing Client Scripts"
        },
        {
            "location": "/dev/writing-client-scripts/index.html#prerequisite",
            "text": "A  Jython stand-alone package  is required to run scripts.  Download either  Jython 2.7 Standalone  (newer, slower to load) or  Jython 2.5 Standalone  (older and slimmer, faster to load) and drop it in your JEB  scripts/  sub-directory.",
            "title": "Prerequisite"
        },
        {
            "location": "/dev/writing-client-scripts/index.html#features",
            "text": "Scripts can:   use the standard  JEB API  use the  Client API package  if run within a client that implements the UI-API, use the  JEB UI Client API   A client script implements the  IScript  interface. Upon execution, the script  run()  entry-point method is provided an  IClientContext  or derived object, such as an  IGraphicalClientContext  for UI clients, such as the official RCP desktop client.",
            "title": "Features"
        },
        {
            "location": "/dev/writing-client-scripts/index.html#a-simple-script",
            "text": "Here is the simplest of all scripts:  from com.pnfsoftware.jeb.client.api import IScript\n\nclass JEB2SampleScript(IScript):\n  def run(self, ctx):\n    print('Hello, JEB version %s' % ctx.getSoftwareVersion())\n    print('- Arguments: %s' % ctx.getArguments())\n    print('- Base directory: %s' % ctx.getBaseDirectory())  Within the official desktop client, scripts can be executed via the  File, Scripts  menu item.  Remember that heavy-lifting operations (such as parsing or background event-driven tasks) should be implemented by back-end plugins in Java.",
            "title": "A Simple Script"
        },
        {
            "location": "/dev/writing-client-scripts/index.html#more-scripts",
            "text": "Check out our  GitHub repository for more sample scripts .",
            "title": "More scripts"
        },
        {
            "location": "/dev/1-getting-started-with-parsers/index.html",
            "text": "JEB Plugin Development Tutorial part 1/8\n\n\nGetting Started with Parsers\n\n\nThe JEB API provides the ability to develop \nparser plugins\n (referred to as \nparsers\n) for any file type. All native JEB plugins use that same API.\n\n\nA parser can process binary data, textual data, or even the output of other parsers, which is the case for debugger or decompiler plugins.\n\n\nThis series of tutorials will help developers understand the major features and organization of the JEB API, and will guide them through the development of their own parsers and plugins. We will use the official front-end - the \nRCP client\n - throughout this series, although extensions development is in no way constricted to the use of a particular front-end.\n\n\n\n\nNote that a Pro license of JEB2 is required to use the API.\n\n\n\n\nLoad a parser\n\n\nThere are two ways to load plugins.\n\n\nRelease model\n\n\nCopy the jar plugin to your \nplugins\n folder. You can configure your plugins folder via the \nEdit, Options\n menu (or \nPreferences\n on Mac). Refer to \nthat section\n for additional details.\n\n\n\n\n\n\nIf you are using third-party (aka, non native) plugins, the release model is easy to use. For example, head over to our GitHub account. You will find a few open-source parsers, such as an \nAndroid OAT parser\n. Instead of compiling them from source, you may decide to use the pre-compiled jars, available in the release  section.\n\n\nWith the release model, the classname is defined in the Jar manifest. There is nothing to configure in the options.\n\n\nIf you have a jar plugin that you would like to use, \nsimply drop it in the plugins folder\n. Then, restart JEB. Your plugin will be automatically loaded.\n\n\nDevelopment model\n\n\nIn that case, you need to specify the classpath of your plugin, as well as its classname (that is, the fully-qualified name of the plugin class, as we will describe later). You can modify these options in the same dialog box, in the Development tab:\n\n\n\n\nThe development model is ideal when actively developing a plugin, and dealing with compiled Java classfiles that have not been packaged yet.\n\n\nCheck if a parser is loaded\n\n\nAs we explained \nearlier in this guide\n, You can check if your parser is loaded by opening the parsers dialog:\n\n\n\n\n\n\nNote that you may also disable parsers, by ticking or unticking the checkbox in front of the parser type.\n\n\nDevelop a new parser\n\n\nJEB plugins are developed in Java. We recommend you to use the Eclipse IDE for plugins development.\n\n\n\n\n\n\nCreate a new Java project\n\n\n\n\nIn Eclipse: \nFile, New, Java Project\n - use the default settings\n\n\n\n\n\n\n\n\nAdd the API to your project. The API can be included by adding the Jar reference to your build path\n\n\n\n\nIn Eclipse: right click on your project, select \nBuild path, Add external archives\n. The API file is contained in the JEB application under \nbin/cl/jeb.jar\n.\n\n\n\n\n\n\n\n\nLink the javadoc to jeb.jar: it is located in \ndoc/apidoc.zip\n\n\n\n\nIn Eclipse: right click on your project and select Build path, configure build path. Expand jeb.jar and edit the javadoc location\n\n\nSet the \nArchive path\n textbobx to point to your \napidoc.zip\n file\n\n\nSet the \nPath within Archive\n textbox to \nreference\n\n\n\n\n\n\n\n\nCreate a new class that implements \nIPlugin\n: it will be the entry point of your project.\n\n\n\n\nIn Eclipse: the project is automatically compiled in a bin/ directory\n\n\n\n\n\n\n\n\nFor example:\n\n\npackage com.jeb.sample;\n\nimport com.pnfsoftware.jeb.core.IPlugin;  // simplest plugin type\n\npublic class SamplePlugin implements IPlugin {\n    @Override\n    public IPluginInformation getPluginInformation() {\n        return new PluginInformation(\nSample\n, \nDescription\n, \nPNF Software\n, Version.create(1, 0));\n    }\n}\n\n\n\n\n\n\nOpen JEB and add your project bin folder to the \nPlugin Classpath\n entries and add the classname: \ncom.jeb.sample.SamplePlugin\n.\n\n\n\n\n\n\n\n\nRestart JEB, you should see a message in the Logger panel: \nDevelopment plugin loaded: class com.jeb.sample.SamplePlugin\n\n\n\n\n\n\nThis means that your project is correctly configured and that you can start the development of your plugin!\n\n\nNext: \nPart 2",
            "title": "Part 1: Getting Started with Parsers"
        },
        {
            "location": "/dev/1-getting-started-with-parsers/index.html#getting-started-with-parsers",
            "text": "The JEB API provides the ability to develop  parser plugins  (referred to as  parsers ) for any file type. All native JEB plugins use that same API.  A parser can process binary data, textual data, or even the output of other parsers, which is the case for debugger or decompiler plugins.  This series of tutorials will help developers understand the major features and organization of the JEB API, and will guide them through the development of their own parsers and plugins. We will use the official front-end - the  RCP client  - throughout this series, although extensions development is in no way constricted to the use of a particular front-end.   Note that a Pro license of JEB2 is required to use the API.",
            "title": "Getting Started with Parsers"
        },
        {
            "location": "/dev/1-getting-started-with-parsers/index.html#load-a-parser",
            "text": "There are two ways to load plugins.",
            "title": "Load a parser"
        },
        {
            "location": "/dev/1-getting-started-with-parsers/index.html#release-model",
            "text": "Copy the jar plugin to your  plugins  folder. You can configure your plugins folder via the  Edit, Options  menu (or  Preferences  on Mac). Refer to  that section  for additional details.    If you are using third-party (aka, non native) plugins, the release model is easy to use. For example, head over to our GitHub account. You will find a few open-source parsers, such as an  Android OAT parser . Instead of compiling them from source, you may decide to use the pre-compiled jars, available in the release  section.  With the release model, the classname is defined in the Jar manifest. There is nothing to configure in the options.  If you have a jar plugin that you would like to use,  simply drop it in the plugins folder . Then, restart JEB. Your plugin will be automatically loaded.",
            "title": "Release model"
        },
        {
            "location": "/dev/1-getting-started-with-parsers/index.html#development-model",
            "text": "In that case, you need to specify the classpath of your plugin, as well as its classname (that is, the fully-qualified name of the plugin class, as we will describe later). You can modify these options in the same dialog box, in the Development tab:   The development model is ideal when actively developing a plugin, and dealing with compiled Java classfiles that have not been packaged yet.",
            "title": "Development model"
        },
        {
            "location": "/dev/1-getting-started-with-parsers/index.html#check-if-a-parser-is-loaded",
            "text": "As we explained  earlier in this guide , You can check if your parser is loaded by opening the parsers dialog:    Note that you may also disable parsers, by ticking or unticking the checkbox in front of the parser type.",
            "title": "Check if a parser is loaded"
        },
        {
            "location": "/dev/1-getting-started-with-parsers/index.html#develop-a-new-parser",
            "text": "JEB plugins are developed in Java. We recommend you to use the Eclipse IDE for plugins development.    Create a new Java project   In Eclipse:  File, New, Java Project  - use the default settings     Add the API to your project. The API can be included by adding the Jar reference to your build path   In Eclipse: right click on your project, select  Build path, Add external archives . The API file is contained in the JEB application under  bin/cl/jeb.jar .     Link the javadoc to jeb.jar: it is located in  doc/apidoc.zip   In Eclipse: right click on your project and select Build path, configure build path. Expand jeb.jar and edit the javadoc location  Set the  Archive path  textbobx to point to your  apidoc.zip  file  Set the  Path within Archive  textbox to  reference     Create a new class that implements  IPlugin : it will be the entry point of your project.   In Eclipse: the project is automatically compiled in a bin/ directory     For example:  package com.jeb.sample;\n\nimport com.pnfsoftware.jeb.core.IPlugin;  // simplest plugin type\n\npublic class SamplePlugin implements IPlugin {\n    @Override\n    public IPluginInformation getPluginInformation() {\n        return new PluginInformation( Sample ,  Description ,  PNF Software , Version.create(1, 0));\n    }\n}   Open JEB and add your project bin folder to the  Plugin Classpath  entries and add the classname:  com.jeb.sample.SamplePlugin .     Restart JEB, you should see a message in the Logger panel:  Development plugin loaded: class com.jeb.sample.SamplePlugin    This means that your project is correctly configured and that you can start the development of your plugin!  Next:  Part 2",
            "title": "Develop a new parser"
        },
        {
            "location": "/dev/2-creating-simple-parser/index.html",
            "text": "JEB Plugin Development Tutorial part 2/8\n\n\nCreating a Simple Parser\n\n\nThe source code for part 2 of this sample plugin is located on GitHub:\n\n\n\n\nClone \nthis repo\n: \ngit clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git\n\n\nSwitch to the \ntutorial2\n branch: \ngit checkout tutorial2\n\n\n\n\nSample file\n\n\nIn this parser development tutorial, we will consider a simple Javascript parser. Let's start with a definition of a test file:\n\n\n#Javascript\n\nfunction a() {\n  alert(\na called\n);\n}\n\nfunction b() {\n  var b = \nb called\n;\n  alert(b);\n}\n\n\n\n\nParser Objective\n\n\nOur parser will split the input JavaScript file into several parts, one for each JavaScript function().\n\n\n\n\nDefined variables will will be displayed in a supplementary tab in a table.\n\n\nThis initial goal is to detect and display the contents of the file. The secondary goal is to define and manage several views, and show how to use the delegation mechanism.\n\n\nGeneric Parser\n\n\nFirst, let's open this js file without modifying anything in JEB.\n\n\n\n\nJEB analyzes the input artifact and built the project as following:\n\n\n\n\nThe top-level \nproject\n represents your current workspace.\n\n\nThe \nartifact\n represents the file that was opened. (If you choose \"File, Add an Artifact...\" from the menu, a new artifact will be added at the same level.)\n\n\nThe children of the artifact are the \nunits\n. Their icon can be specified, if none, you will see the default one .\n\n\n\n\nJEB provides a default generic parser that displays any file. It contains two fragments:\n\n\n\n\na Description panel with generic information related to unit\n\n\nan Hex Dump view which displays the content of the object as hexadecimal.\n\n\n\n\nDetect the js file\n\n\nUpon loading a file, the first step JEB takes is ask all parsers if they are able to handle the input artifact (in our case, a file). So, the first step is to add the detection for this JavaScript (js) file.\n\n\n\n\nFor the sake of making this tutorial simple, we will suppose that all our js files start with a \n\"#Javascript\"\n tag.\n\n\n\n\nIn \npart 1\n, we learned that IPlugin is the entry point of the plugin; however, it only defines a \ngetPluginInformation()\n method.\n\n\nLet's start to check all classes/interfaces that extend \nIPlugin\n (in Eclipse, right click on \nIPlugin, Open Type Hierarchy\n).\n\n\n\n\nWhat we have here:\n\n\n\n\nour own plugin \nSamplePlugin\n class\n\n\nIEnginesPlugin\n for Engines plugins (refer to separate tutorial)\n\n\nIUnitIdentifier\n for Parser plugins. To free developers from the task of implementing all methods of IUnitIdentifier, the abstract class \nAbstractUnitIdentifier\n is provided. Let's extend it instead of IPlugin or IUnitIdentifier.\n\n\n\n\nWe see that only two methods are not implemented:\n\n\n\n\ncanIdentify\n: used to detect if the parser should to be used (the one we were looking for!)\n\n\nprepare\n: used to create an \nIUnit\n that will perform the processing\n\n\n\n\nLet's check canIdentify parameters in the API:\n\n\n\n\nIInput\n is a reference to the input file or stream, we can read data from here.\n\n\nIUnitCreator\n is the parent that created this unit (parsers are producing units or type IUnit). We will use this parameter in the tutorial explaining how delegation works.\n\n\n\n\ncanIdentify could use IInput.getHeader, IInput.getStream or other method to detect specific file type. Here, we will use AbstractUnitIdentifier.checkBytes which provides an easy way to check header as you can see:\n\n\nprivate final static byte[] JS_HEADER = \n#Javascript\n.getBytes();\n\n@Override\npublic boolean canIdentify(IInput input, IUnitCreator parent) {\n    return checkBytes(input, 0, JS_HEADER);\n}\n\n\n\n\nWe are now ready, let's start JEB.\n\n\n\n\nNote:\n you may see the following error in the logger:\n\nUnit plugin class com.jeb.sample.SamplePlugin must have a public no-argument constructor\n\nThis means that you did not provide a default constructor without argument.\nLet's use this one:\n\n\n\n\npublic SamplePlugin() {\n    super(\nJavascript\n, 0);\n}\n\n\n\n\nOpen test.js. You should see this:\n\n\n\n\nThe default parser did not create the generic unit for js file! That's because there is nothing defined in the \nprepare\n method. Keep on reading.\n\n\nBuild a unit\n\n\nLook back at the prepare method. It should return an \nIUnit\n. \n\n\nThe IUnit will be the main processing class, so it is recommended to build a dedicated class. Just like we did for IPlugin, we will use one of the default convenience abstract classes provided: \nAbstractUnit\n.\n\n\npublic class SampleUnit extends AbstractUnit {\n    public SampleUnit(String name, IInput input, IUnitProcessor unitProcessor, IUnitCreator parent, IPropertyDefinitionManager pdm) {\n        super(\njs\n, name, unitProcessor, parent, pdm);\n    }\n\n    @Override\n    public boolean process() {\n        // indicates that the processing is already done: process won't be called again in future\n        setProcessed(true);\n        // default is false. True indicates that processing is successful.\n        return true;\n    }\n}\n\n\n\n\nand the code of the caller:\n\n\n@Override\npublic IUnit prepare(String name, IInput input, IUnitProcessor unitProcessor, IUnitCreator parent) {\n    return new SampleUnit(name, input, unitProcessor, parent, pdm);\n}\n\n\n\n\nYou can test your parser:\n\n\n\n\nNot very exciting. The content of the file is not even displayed. \nAbstractUnit\n is a simple unit with the description panel. Its constructor does not use the IInput.\n\n\nLet's try something else: what are all available subclasses that we have:\n\n\n\n\nLet's use another default implementation: \nAbstractBinaryUnit\n.\n\n\npublic class SampleUnit extends AbstractBinaryUnit {\n    public SampleUnit(String name, IInput input, IUnitProcessor unitProcessor, IUnitCreator parent, IPropertyDefinitionManager pdm) {\n        super(null, input, \njs\n, name, unitProcessor, parent, pdm);\n    }\n}\n\n\n\n\n\n\nSo, now we have 2 tabs for a single unit. Each tab is a representation of a JEB Document.\nDefault documents for a Binary Unit are Description and Hex Dump. They both display text.\n\n\nNote: the description Document is a default document that is always attached to a unit. You can modify its content by overriding IUnit.getDescription.\n\n\nAdd a Document\n\n\nJEB provides the ability for units to produce all sorts of documents to be represented by clients.\n\n\nThere are three types of documents, and default implementations are provided:\n\n\n\n\nText\n buffers (for arbitrary long line-based documents)\n\n\nTables\n\n\nTrees\n and \ntable trees\n\n\n\n\n\n\nLet's start with the simplest document: a text document. We will use the provided AsciiDocument implementation.\n\n\nThe display is delegated to an IUnitFormatter. This display can be modified by overriding the IUnit.getFormatter method.\n\n\n@Override\npublic IUnitFormatter getFormatter() {\n    return new UnitFormatterAdapter(new AbstractUnitRepresentation(\njavascript raw code\n, true) {\n        @Override\n        public IGenericDocument getDocument() {\n            return new AsciiDocument(getInput());\n        }\n    });\n}\n\n\n\n\nThe result is what we expected:\n\n\n\n\nNext: \nPart 3",
            "title": "Part 2: Creating a Simple Parser"
        },
        {
            "location": "/dev/2-creating-simple-parser/index.html#creating-a-simple-parser",
            "text": "The source code for part 2 of this sample plugin is located on GitHub:   Clone  this repo :  git clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git  Switch to the  tutorial2  branch:  git checkout tutorial2",
            "title": "Creating a Simple Parser"
        },
        {
            "location": "/dev/2-creating-simple-parser/index.html#sample-file",
            "text": "In this parser development tutorial, we will consider a simple Javascript parser. Let's start with a definition of a test file:  #Javascript\n\nfunction a() {\n  alert( a called );\n}\n\nfunction b() {\n  var b =  b called ;\n  alert(b);\n}",
            "title": "Sample file"
        },
        {
            "location": "/dev/2-creating-simple-parser/index.html#parser-objective",
            "text": "Our parser will split the input JavaScript file into several parts, one for each JavaScript function().   Defined variables will will be displayed in a supplementary tab in a table.  This initial goal is to detect and display the contents of the file. The secondary goal is to define and manage several views, and show how to use the delegation mechanism.",
            "title": "Parser Objective"
        },
        {
            "location": "/dev/2-creating-simple-parser/index.html#generic-parser",
            "text": "First, let's open this js file without modifying anything in JEB.   JEB analyzes the input artifact and built the project as following:   The top-level  project  represents your current workspace.  The  artifact  represents the file that was opened. (If you choose \"File, Add an Artifact...\" from the menu, a new artifact will be added at the same level.)  The children of the artifact are the  units . Their icon can be specified, if none, you will see the default one .   JEB provides a default generic parser that displays any file. It contains two fragments:   a Description panel with generic information related to unit  an Hex Dump view which displays the content of the object as hexadecimal.",
            "title": "Generic Parser"
        },
        {
            "location": "/dev/2-creating-simple-parser/index.html#detect-the-js-file",
            "text": "Upon loading a file, the first step JEB takes is ask all parsers if they are able to handle the input artifact (in our case, a file). So, the first step is to add the detection for this JavaScript (js) file.   For the sake of making this tutorial simple, we will suppose that all our js files start with a  \"#Javascript\"  tag.   In  part 1 , we learned that IPlugin is the entry point of the plugin; however, it only defines a  getPluginInformation()  method.  Let's start to check all classes/interfaces that extend  IPlugin  (in Eclipse, right click on  IPlugin, Open Type Hierarchy ).   What we have here:   our own plugin  SamplePlugin  class  IEnginesPlugin  for Engines plugins (refer to separate tutorial)  IUnitIdentifier  for Parser plugins. To free developers from the task of implementing all methods of IUnitIdentifier, the abstract class  AbstractUnitIdentifier  is provided. Let's extend it instead of IPlugin or IUnitIdentifier.   We see that only two methods are not implemented:   canIdentify : used to detect if the parser should to be used (the one we were looking for!)  prepare : used to create an  IUnit  that will perform the processing   Let's check canIdentify parameters in the API:   IInput  is a reference to the input file or stream, we can read data from here.  IUnitCreator  is the parent that created this unit (parsers are producing units or type IUnit). We will use this parameter in the tutorial explaining how delegation works.   canIdentify could use IInput.getHeader, IInput.getStream or other method to detect specific file type. Here, we will use AbstractUnitIdentifier.checkBytes which provides an easy way to check header as you can see:  private final static byte[] JS_HEADER =  #Javascript .getBytes();\n\n@Override\npublic boolean canIdentify(IInput input, IUnitCreator parent) {\n    return checkBytes(input, 0, JS_HEADER);\n}  We are now ready, let's start JEB.   Note:  you may see the following error in the logger: Unit plugin class com.jeb.sample.SamplePlugin must have a public no-argument constructor \nThis means that you did not provide a default constructor without argument.\nLet's use this one:   public SamplePlugin() {\n    super( Javascript , 0);\n}  Open test.js. You should see this:   The default parser did not create the generic unit for js file! That's because there is nothing defined in the  prepare  method. Keep on reading.",
            "title": "Detect the js file"
        },
        {
            "location": "/dev/2-creating-simple-parser/index.html#build-a-unit",
            "text": "Look back at the prepare method. It should return an  IUnit .   The IUnit will be the main processing class, so it is recommended to build a dedicated class. Just like we did for IPlugin, we will use one of the default convenience abstract classes provided:  AbstractUnit .  public class SampleUnit extends AbstractUnit {\n    public SampleUnit(String name, IInput input, IUnitProcessor unitProcessor, IUnitCreator parent, IPropertyDefinitionManager pdm) {\n        super( js , name, unitProcessor, parent, pdm);\n    }\n\n    @Override\n    public boolean process() {\n        // indicates that the processing is already done: process won't be called again in future\n        setProcessed(true);\n        // default is false. True indicates that processing is successful.\n        return true;\n    }\n}  and the code of the caller:  @Override\npublic IUnit prepare(String name, IInput input, IUnitProcessor unitProcessor, IUnitCreator parent) {\n    return new SampleUnit(name, input, unitProcessor, parent, pdm);\n}  You can test your parser:   Not very exciting. The content of the file is not even displayed.  AbstractUnit  is a simple unit with the description panel. Its constructor does not use the IInput.  Let's try something else: what are all available subclasses that we have:   Let's use another default implementation:  AbstractBinaryUnit .  public class SampleUnit extends AbstractBinaryUnit {\n    public SampleUnit(String name, IInput input, IUnitProcessor unitProcessor, IUnitCreator parent, IPropertyDefinitionManager pdm) {\n        super(null, input,  js , name, unitProcessor, parent, pdm);\n    }\n}   So, now we have 2 tabs for a single unit. Each tab is a representation of a JEB Document.\nDefault documents for a Binary Unit are Description and Hex Dump. They both display text.  Note: the description Document is a default document that is always attached to a unit. You can modify its content by overriding IUnit.getDescription.",
            "title": "Build a unit"
        },
        {
            "location": "/dev/2-creating-simple-parser/index.html#add-a-document",
            "text": "JEB provides the ability for units to produce all sorts of documents to be represented by clients.  There are three types of documents, and default implementations are provided:   Text  buffers (for arbitrary long line-based documents)  Tables  Trees  and  table trees    Let's start with the simplest document: a text document. We will use the provided AsciiDocument implementation.  The display is delegated to an IUnitFormatter. This display can be modified by overriding the IUnit.getFormatter method.  @Override\npublic IUnitFormatter getFormatter() {\n    return new UnitFormatterAdapter(new AbstractUnitRepresentation( javascript raw code , true) {\n        @Override\n        public IGenericDocument getDocument() {\n            return new AsciiDocument(getInput());\n        }\n    });\n}  The result is what we expected:   Next:  Part 3",
            "title": "Add a Document"
        },
        {
            "location": "/dev/3-documents-delegation/index.html",
            "text": "JEB Plugin Development Tutorial part 3/8\n\n\nDocuments and Delegation\n\n\nThe source code for part 3 of this sample plugin is located on GitHub:\n\n\n\n\nClone \nthis repo\n: \ngit clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git\n\n\nSwitch to the \ntutorial3\n branch: \ngit checkout tutorial3\n\n\n\n\nProcess the input\n\n\nIn the previous part, we built a single document that displays the whole JavaScript file.\n\n\nImagine we have large functions that we would like to split using the following simple rule: \none function per document\n.\n\n\nLet's detail the flow of execution around \nIUnit\n:\n\n\n\n\nWhen opening a new file, all the \nIPlugin.canIdentify\n methods are called.\n\n\nIf identified, the method \nIPlugin.prepare\n is called, which will create a new unit.\n\n\nWhen opening the unit, if the unit was not previously processed, the method \nIUnit.process\n method will be called.\n\n\nAt last, \nIUnit.getFormatter\n is used to display the result of processing.\n\n\n\n\nThe \nprocess\n method is where the heavy-lifting of your parser should be located. If you need to pre-process data, you may call the process method in \nIUnitIdentifier.prepare\n. Since we don't need it for now, we won't do it.\n\n\nSo let's start with implementing \nprocess()\n. First, we need to extract the JavaScript and split this test block into two functions. For the sake of this tutorial, we will use \nMozilla Rhino\n to deal with JavaScript lexing and parsing. You can download it \nhere\n.\n\n\nFirst, add \nrhino-*.jar\n to your eclipse project (you can attach the javadoc to this .jar, the process is like adding javadoc to jeb.jar).\nThen, use the following snippet to extract the Functions from Javascript:\n\n\nprivate static final ILogger logger = GlobalLog.getLogger(SampleUnit.class);\n\nprivate AstRoot root = null;\nprivate List\nFunctionNode\n functions = new ArrayList\nFunctionNode\n();\n\n@Override\npublic boolean process() {\n    // parse the javascript\n    IRFactory factory = new IRFactory();\n    try {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(getInput().getStream()));\n        reader.readLine(); // ignore first line with #Javascript\n        root = factory.parse(reader, null, 0);\n    }\n    catch(IOException e) {\n        logger.catching(e);\n        return false;\n    }\n\n    // save functions\n    List\nAstNode\n statements = root.getStatements();\n    for(AstNode statement: statements) {\n        if(statement.getType() == Token.FUNCTION) {\n            functions.add((FunctionNode)statement);\n        }\n    }\n\n    // done\n    setProcessed(true);\n    return true;\n}\n\n\n\n\nAs you can see here, \nprocess()\n is only extracting data: \nFunctionNode\n objects are saved in the functions list.\n\n\nNote: JEB2 provides global logging facility that you can use anytime to send messages in the \nLogger\n panel. Do not hesitate to use it to investigate your code. We also recommend you enable the \nDevelopment Mode\n in the \nOptions\n panel: this will allow logging of debug and trace messages.\n\n\nimport com.pnfsoftware.jeb.util.logging.GlobalLog;\nimport com.pnfsoftware.jeb.util.logging.ILogger;\n\npublic class Xxx {\n    private static final ILogger logger = GlobalLog.getLogger(Xxx.class);\n    ...\n\n\n\n\nAdd a Document per function\n\n\nNow, let's modify the \ngetFormatter\n method to change rendering, adding as many tabs (documents) as defined functions.\n\n\n@Override\npublic IUnitFormatter getFormatter() {\n    UnitFormatterAdapter adapter = new UnitFormatterAdapter(new AbstractUnitRepresentation(\njavascript raw code\n, true) {\n        @Override\n        public IGenericDocument getDocument() {\n                return new AsciiDocument(getInput());\n        }\n    });\n    if(functions != null) {\n        for(final FunctionNode function: functions) {\n            adapter.addDocumentPresentation(new AbstractUnitRepresentation(function.getName()) {\n                @Override\n                public IGenericDocument getDocument() {\n                    return new AsciiDocument(new BytesInput(function.toSource().getBytes()));\n                }\n            });\n        }\n    }\n    return adapter;\n}\n\n\n\n\nWe called the method \nUnitFormatterAdapter.addDocumentPresentation\n to add more documents.\n\n\n\n\nNote: since \nAsciiDocument\n requires an \nIInput\n as entry, we used the most appropriate implementation:\n\n\n\n\n\n\nNow, start JEB.\n\n\n\n\nNote: You will probably see this exception: \njava.lang.NoClassDefFoundError: org/mozilla/javascript/IRFactory\n. Remember that js.jar was not added to JEB classpath. Add it to your plugin classpath (in the \nOptions\n panel - refer to Part 1 of this tutorial).\n\n\n\n\nIf all works well, you shall to see two additional tabs:\n\n\n\n\nDelegate to another Unit\n\n\nThese new documents are great but what if we have lots of functions? We will have lots of tabs and it will become unreadable. One solution would be to add these FunctionNodes as children unit of the test.js unit node. We can delegate the creation of those units to the unit processor.\n\n\nHere is a short explanation of delegation: assume have a zip file containing pdf, apk, js... You do not want to write a single parser that manages all those file types. A better approach is to have a Zip parser that will delegate parsing of its contents. That puts the Unit Processor in charge of finding the best Unit that match the file type: DEX Unit, Pdf Unit... and even our new Javascript Unit.\n\n\n\n\nMore on delegation \nhere\n. \n\n\n\n\nSo how to do it? You need to slightly modify process():\n\n\n// save functions\nList\nAstNode\n statements = root.getStatements();\nfor(AstNode statement: statements) {\n        if(statement.getType() == Token.FUNCTION) {\n            FunctionNode function = (FunctionNode)statement;\n            functions.add(function);\n            IUnit jsUnit = getUnitProcessor().process(function.getName(), new BytesInput(function.toSource().getBytes()), this);\n            if(jsUnit != null) {\n                addChildUnit(jsUnit);\n            }\n        }\n}\n\n\n\n\nYou should be able to see a generic binary output for \na\n and \nb\n.\n\n\nExercice\n\n\nBuild a simple JavascriptPlugin that takes advantage of the delegation. The solution lies in branch \ntutorial3\n of this sample plugin repository.\n\n\nDo not forget to register the parser plugin's classname in the options panel. You should obtain something like this:\n\n\n\n\nNext: \nPart 4",
            "title": "Part 3: Documents and Delegation"
        },
        {
            "location": "/dev/3-documents-delegation/index.html#documents-and-delegation",
            "text": "The source code for part 3 of this sample plugin is located on GitHub:   Clone  this repo :  git clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git  Switch to the  tutorial3  branch:  git checkout tutorial3",
            "title": "Documents and Delegation"
        },
        {
            "location": "/dev/3-documents-delegation/index.html#process-the-input",
            "text": "In the previous part, we built a single document that displays the whole JavaScript file.  Imagine we have large functions that we would like to split using the following simple rule:  one function per document .  Let's detail the flow of execution around  IUnit :   When opening a new file, all the  IPlugin.canIdentify  methods are called.  If identified, the method  IPlugin.prepare  is called, which will create a new unit.  When opening the unit, if the unit was not previously processed, the method  IUnit.process  method will be called.  At last,  IUnit.getFormatter  is used to display the result of processing.   The  process  method is where the heavy-lifting of your parser should be located. If you need to pre-process data, you may call the process method in  IUnitIdentifier.prepare . Since we don't need it for now, we won't do it.  So let's start with implementing  process() . First, we need to extract the JavaScript and split this test block into two functions. For the sake of this tutorial, we will use  Mozilla Rhino  to deal with JavaScript lexing and parsing. You can download it  here .  First, add  rhino-*.jar  to your eclipse project (you can attach the javadoc to this .jar, the process is like adding javadoc to jeb.jar).\nThen, use the following snippet to extract the Functions from Javascript:  private static final ILogger logger = GlobalLog.getLogger(SampleUnit.class);\n\nprivate AstRoot root = null;\nprivate List FunctionNode  functions = new ArrayList FunctionNode ();\n\n@Override\npublic boolean process() {\n    // parse the javascript\n    IRFactory factory = new IRFactory();\n    try {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(getInput().getStream()));\n        reader.readLine(); // ignore first line with #Javascript\n        root = factory.parse(reader, null, 0);\n    }\n    catch(IOException e) {\n        logger.catching(e);\n        return false;\n    }\n\n    // save functions\n    List AstNode  statements = root.getStatements();\n    for(AstNode statement: statements) {\n        if(statement.getType() == Token.FUNCTION) {\n            functions.add((FunctionNode)statement);\n        }\n    }\n\n    // done\n    setProcessed(true);\n    return true;\n}  As you can see here,  process()  is only extracting data:  FunctionNode  objects are saved in the functions list.  Note: JEB2 provides global logging facility that you can use anytime to send messages in the  Logger  panel. Do not hesitate to use it to investigate your code. We also recommend you enable the  Development Mode  in the  Options  panel: this will allow logging of debug and trace messages.  import com.pnfsoftware.jeb.util.logging.GlobalLog;\nimport com.pnfsoftware.jeb.util.logging.ILogger;\n\npublic class Xxx {\n    private static final ILogger logger = GlobalLog.getLogger(Xxx.class);\n    ...",
            "title": "Process the input"
        },
        {
            "location": "/dev/3-documents-delegation/index.html#add-a-document-per-function",
            "text": "Now, let's modify the  getFormatter  method to change rendering, adding as many tabs (documents) as defined functions.  @Override\npublic IUnitFormatter getFormatter() {\n    UnitFormatterAdapter adapter = new UnitFormatterAdapter(new AbstractUnitRepresentation( javascript raw code , true) {\n        @Override\n        public IGenericDocument getDocument() {\n                return new AsciiDocument(getInput());\n        }\n    });\n    if(functions != null) {\n        for(final FunctionNode function: functions) {\n            adapter.addDocumentPresentation(new AbstractUnitRepresentation(function.getName()) {\n                @Override\n                public IGenericDocument getDocument() {\n                    return new AsciiDocument(new BytesInput(function.toSource().getBytes()));\n                }\n            });\n        }\n    }\n    return adapter;\n}  We called the method  UnitFormatterAdapter.addDocumentPresentation  to add more documents.   Note: since  AsciiDocument  requires an  IInput  as entry, we used the most appropriate implementation:    Now, start JEB.   Note: You will probably see this exception:  java.lang.NoClassDefFoundError: org/mozilla/javascript/IRFactory . Remember that js.jar was not added to JEB classpath. Add it to your plugin classpath (in the  Options  panel - refer to Part 1 of this tutorial).   If all works well, you shall to see two additional tabs:",
            "title": "Add a Document per function"
        },
        {
            "location": "/dev/3-documents-delegation/index.html#delegate-to-another-unit",
            "text": "These new documents are great but what if we have lots of functions? We will have lots of tabs and it will become unreadable. One solution would be to add these FunctionNodes as children unit of the test.js unit node. We can delegate the creation of those units to the unit processor.  Here is a short explanation of delegation: assume have a zip file containing pdf, apk, js... You do not want to write a single parser that manages all those file types. A better approach is to have a Zip parser that will delegate parsing of its contents. That puts the Unit Processor in charge of finding the best Unit that match the file type: DEX Unit, Pdf Unit... and even our new Javascript Unit.   More on delegation  here .    So how to do it? You need to slightly modify process():  // save functions\nList AstNode  statements = root.getStatements();\nfor(AstNode statement: statements) {\n        if(statement.getType() == Token.FUNCTION) {\n            FunctionNode function = (FunctionNode)statement;\n            functions.add(function);\n            IUnit jsUnit = getUnitProcessor().process(function.getName(), new BytesInput(function.toSource().getBytes()), this);\n            if(jsUnit != null) {\n                addChildUnit(jsUnit);\n            }\n        }\n}  You should be able to see a generic binary output for  a  and  b .",
            "title": "Delegate to another Unit"
        },
        {
            "location": "/dev/3-documents-delegation/index.html#exercice",
            "text": "Build a simple JavascriptPlugin that takes advantage of the delegation. The solution lies in branch  tutorial3  of this sample plugin repository.  Do not forget to register the parser plugin's classname in the options panel. You should obtain something like this:   Next:  Part 4",
            "title": "Exercice"
        },
        {
            "location": "/dev/4-tables-trees/index.html",
            "text": "JEB Plugin Development Tutorial part 4/8\n\n\nTables and Trees\n\n\nThe interfaces \nITextDocument\n, \nITableDocument\n and \nITreeDocument\n are designed to provide buffered data: data is not generated nor displayed entirely (which could lead to performance/memory problem). It is split into \nParts\n (eg, \nITableDocumentPart\n).\n\n\nWhen implementing an \nIXxxDocument\n, you can choose to render the full model (for instance if the model is relatively small) or just one or more parts. A client requests as many parts as they see fit. Those indications are hints; ultimately, your plugin has the final say in how many parts it decides to return.\n\n\nNow, let's check two types of documents that we haven't seen yet: \nTable\n and \nTree\n.\n\n\nTable\n\n\nFor simple tables, you can use \nStaticTableDocument\n.\n\n\nSee below an example of a Table having 2 columns, and containing 2 rows.\n\n\nprivate ITableDocument getStatisticsTable() {\n    List\nTableRow\n rows = new ArrayList\n();\n    rows.add(new TableRow(new Cell(\nLength\n), new Cell(Integer.toString(root.getLength()))));\n    rows.add(new TableRow(new Cell(\nType\n), new Cell(Integer.toString(root.getType()))));\n    return new StaticTableDocument(Arrays.asList(\nProperty\n, \nValue\n), rows);\n}\n\n\n\n\nExercice: Update the \ngetFormatter()\n method accordingly to include new Documents (use the \nIUnitFormatter.addPresentation()\n method). The result should look like:\n\n\n\n\nTree\n\n\nFor simple trees, you can use \nStaticTreeDocument\n.\n\n\nSee below an example of a Tree that displays all function parameters.\n\n\nprivate ITreeDocument getFunctionsTree() {\n    List\nNode\n treeRoot = new ArrayList\n();\n    try {\n        if(functions != null) {\n            for(FunctionNode function: functions) {\n                treeRoot.add(buildFunctionNode(function));\n            }\n        }\n    }\n    catch(Exception e) {\n        logger.catching(e);\n    }\n    return new StaticTreeDocument(treeRoot);\n}\n\nprivate Node buildFunctionNode(FunctionNode function) {\n    Node functionNode = new Node(function.getName());\n    if(function.getParamCount() \n 0) {\n        for(AstNode var: function.getParams()) {\n            functionNode.addChild(new Node(((Name)var).getIdentifier()));\n        }\n    }\n    return functionNode;\n}\n\n\n\n\n\n\nNext: \nPart 5",
            "title": "Part 4: Tables and Trees"
        },
        {
            "location": "/dev/4-tables-trees/index.html#tables-and-trees",
            "text": "The interfaces  ITextDocument ,  ITableDocument  and  ITreeDocument  are designed to provide buffered data: data is not generated nor displayed entirely (which could lead to performance/memory problem). It is split into  Parts  (eg,  ITableDocumentPart ).  When implementing an  IXxxDocument , you can choose to render the full model (for instance if the model is relatively small) or just one or more parts. A client requests as many parts as they see fit. Those indications are hints; ultimately, your plugin has the final say in how many parts it decides to return.  Now, let's check two types of documents that we haven't seen yet:  Table  and  Tree .",
            "title": "Tables and Trees"
        },
        {
            "location": "/dev/4-tables-trees/index.html#table",
            "text": "For simple tables, you can use  StaticTableDocument .  See below an example of a Table having 2 columns, and containing 2 rows.  private ITableDocument getStatisticsTable() {\n    List TableRow  rows = new ArrayList ();\n    rows.add(new TableRow(new Cell( Length ), new Cell(Integer.toString(root.getLength()))));\n    rows.add(new TableRow(new Cell( Type ), new Cell(Integer.toString(root.getType()))));\n    return new StaticTableDocument(Arrays.asList( Property ,  Value ), rows);\n}  Exercice: Update the  getFormatter()  method accordingly to include new Documents (use the  IUnitFormatter.addPresentation()  method). The result should look like:",
            "title": "Table"
        },
        {
            "location": "/dev/4-tables-trees/index.html#tree",
            "text": "For simple trees, you can use  StaticTreeDocument .  See below an example of a Tree that displays all function parameters.  private ITreeDocument getFunctionsTree() {\n    List Node  treeRoot = new ArrayList ();\n    try {\n        if(functions != null) {\n            for(FunctionNode function: functions) {\n                treeRoot.add(buildFunctionNode(function));\n            }\n        }\n    }\n    catch(Exception e) {\n        logger.catching(e);\n    }\n    return new StaticTreeDocument(treeRoot);\n}\n\nprivate Node buildFunctionNode(FunctionNode function) {\n    Node functionNode = new Node(function.getName());\n    if(function.getParamCount()   0) {\n        for(AstNode var: function.getParams()) {\n            functionNode.addChild(new Node(((Name)var).getIdentifier()));\n        }\n    }\n    return functionNode;\n}   Next:  Part 5",
            "title": "Tree"
        },
        {
            "location": "/dev/5-development-tips/index.html",
            "text": "JEB Plugin Development Tutorial part 5/8\n\n\nDevelopment Tips\n\n\nThis tutorial aggregates a collection of tips that can help you during plugin development.\n\n\nLogging\n\n\nCreating Loggers\n\n\nCreating a new \nlogger\n with the JEB API is simple:\n\n\nprivate static final ILogger logger = GlobalLog.getLogger(MyClass.class);\n\n\n\n\nIt is good practice to create one logger per class. Loggers can be customized one by one, or globally via the \nGlobalLog\n factory.\n\n\nUsing Loggers\n\n\nThere are several level of logs (error, warning, info, ...) and the logger methods use 2 parameters:\n\n\n\n\nthe message to display\n\n\nthe parameters of the message, as it is done for String.format() method.\n\n\n\n\nlogger.info(\nHello %s\n, \nWorld\n);\n\n\n\n\nEnabling Debug and Trace levels\n\n\nBy default, debug and trace logs are not displayed. You can activate them by ticking the Development mode in the Options menu:\n\n\n\n\nLogging destinations\n\n\nBy default, JEB sends log data to the Logger view in the RCP client. Additional sinks canbe added, such as buffers or output streams. For instance, if you would like to collect all logs to a file named \njeb-test-output.log\n in your TEMP folder, your plugin could execute the following:\n\n\nString foldername = System.getProperty(\njava.io.tmpdir\n);\nFile folder = foldername != null ? new File(foldername): TestData.getTestDataRoot();\nFile file = new File(folder, \njeb-test-output.log\n);\nGlobalLog.addDestinationStream(new PrintStream(file));\n\n\n\n\n\n\nBe careful, \nGlobalLog\n is a global factory object, that impacts the entire application.\n\n\n\n\nDebugging\n\n\nIf you are familiar with Eclipse and development tools in general, you know how useful proper debugging facility are: the program can be stopped and paused, current variables can be examined, etc. It is especially handy when troubleshooting a corner-case problem in your plugin.\n\n\nJEB can be debugged using a method called \nremote debugging\n. What you need to do is:\n\n\n\n\nConfigure JEB to listen for debug connections\n\n\nConnect Eclipse to JEB\n\n\n\n\nDebugging setup: step-by-step\n\n\nStart JEB using the following command-line from your JEB base directory:\n\n\n\n\nOn Windows/Linux: \njava -Xdebug -Xrunjdwp:transport=dt_socket,address=8001,server=y,suspend=y -jar bin/plugins/org.eclipse.equinox.launcher_XXXXXXXXXXXX.jar\n\n\nOn macOS: \njava -XstartOnFirstThread -Xdebug -Xrunjdwp:transport=dt_socket,address=8001,server=y,suspend=y -jar bin/plugins/org.eclipse.equinox.launcher_XXXXXXXXXXXX.jar\n\n\n\n\n\n\nDon't forget to replace \nXXXXXXXXXXXX\n by your current Equinox package version.\n\n\n\n\nJEB is not started yet: it is waiting for a debugger connection on port 8001\n\n\nGo to Eclipse:\n\n\n\n\nSelect \nRun, Debug Configuration...\n\n\nCreate a new entry in \nRemote Java Application\n and change the port to 8001 (keep the host as \nlocalhost\n)\n\n\nSelect Debug\n\n\n\n\n\n\nJEB should be launched and you may be able to stop when putting breakpoints in code.\n\n\nIn practice, the true entry-point of a plugin is its no-argument constructor. You may decide to place a breakpoint there. You may also choose to stop in the \ncanIdentify()\n method, which is appropriate for \nprocessor plugins\n such as this sample JavaScript parser.\n\n\nLaunching several instances\n\n\nJEB provides a fully customizable workspace area. Panels can be adjusted, stacked, minimized, expanded, etc. That data is persisted into a workspace folder.\n\n\n\n\nYou may have a need to to launch several instances of JEB, for instance because you have long processing on a first instance, and would like to continue investigating another task. If you try to launch a second instance, you are likely to see this error message:\n\n\n\n\nThis indicates a workspace conflict.\n\n\nIt is possible to launch a second (or more) instances of the JEB client by appending the \n-data @none\n parameters to the command line. Here, @none indicates that no workspace data shall be used or saved. (You may decide to persist that secondary workspace by providing a folder instead of @none.)\n\n\nIf you wish to modify your startup scripts to never record workspace layout data, and therefore have the ability to conveniently start as many instances of JEB as you'd like, here are the modifications to do:\n\n\nOn Linux/Mac OS:\n\n\n$JAVA -jar $SCRIPTDIR/bin/cl/jeb.jar $@\nto \n$JAVA -data @none -jar $SCRIPTDIR/bin/cl/jeb.jar $@\n\n\n\n\nOn Windows:\n\n\n%JAVA% -jar \n%~dp0bin\\cl\\jeb.jar\n %*\nto\n%JAVA% -data @none -jar \n%~dp0bin\\cl\\jeb.jar\n %*\n\n\n\n\nNext: \nPart 6",
            "title": "Part 5: Development Tips"
        },
        {
            "location": "/dev/5-development-tips/index.html#development-tips",
            "text": "This tutorial aggregates a collection of tips that can help you during plugin development.",
            "title": "Development Tips"
        },
        {
            "location": "/dev/5-development-tips/index.html#logging",
            "text": "",
            "title": "Logging"
        },
        {
            "location": "/dev/5-development-tips/index.html#creating-loggers",
            "text": "Creating a new  logger  with the JEB API is simple:  private static final ILogger logger = GlobalLog.getLogger(MyClass.class);  It is good practice to create one logger per class. Loggers can be customized one by one, or globally via the  GlobalLog  factory.",
            "title": "Creating Loggers"
        },
        {
            "location": "/dev/5-development-tips/index.html#using-loggers",
            "text": "There are several level of logs (error, warning, info, ...) and the logger methods use 2 parameters:   the message to display  the parameters of the message, as it is done for String.format() method.   logger.info( Hello %s ,  World );",
            "title": "Using Loggers"
        },
        {
            "location": "/dev/5-development-tips/index.html#enabling-debug-and-trace-levels",
            "text": "By default, debug and trace logs are not displayed. You can activate them by ticking the Development mode in the Options menu:",
            "title": "Enabling Debug and Trace levels"
        },
        {
            "location": "/dev/5-development-tips/index.html#logging-destinations",
            "text": "By default, JEB sends log data to the Logger view in the RCP client. Additional sinks canbe added, such as buffers or output streams. For instance, if you would like to collect all logs to a file named  jeb-test-output.log  in your TEMP folder, your plugin could execute the following:  String foldername = System.getProperty( java.io.tmpdir );\nFile folder = foldername != null ? new File(foldername): TestData.getTestDataRoot();\nFile file = new File(folder,  jeb-test-output.log );\nGlobalLog.addDestinationStream(new PrintStream(file));   Be careful,  GlobalLog  is a global factory object, that impacts the entire application.",
            "title": "Logging destinations"
        },
        {
            "location": "/dev/5-development-tips/index.html#debugging",
            "text": "If you are familiar with Eclipse and development tools in general, you know how useful proper debugging facility are: the program can be stopped and paused, current variables can be examined, etc. It is especially handy when troubleshooting a corner-case problem in your plugin.  JEB can be debugged using a method called  remote debugging . What you need to do is:   Configure JEB to listen for debug connections  Connect Eclipse to JEB",
            "title": "Debugging"
        },
        {
            "location": "/dev/5-development-tips/index.html#debugging-setup-step-by-step",
            "text": "Start JEB using the following command-line from your JEB base directory:   On Windows/Linux:  java -Xdebug -Xrunjdwp:transport=dt_socket,address=8001,server=y,suspend=y -jar bin/plugins/org.eclipse.equinox.launcher_XXXXXXXXXXXX.jar  On macOS:  java -XstartOnFirstThread -Xdebug -Xrunjdwp:transport=dt_socket,address=8001,server=y,suspend=y -jar bin/plugins/org.eclipse.equinox.launcher_XXXXXXXXXXXX.jar    Don't forget to replace  XXXXXXXXXXXX  by your current Equinox package version.   JEB is not started yet: it is waiting for a debugger connection on port 8001  Go to Eclipse:   Select  Run, Debug Configuration...  Create a new entry in  Remote Java Application  and change the port to 8001 (keep the host as  localhost )  Select Debug    JEB should be launched and you may be able to stop when putting breakpoints in code.  In practice, the true entry-point of a plugin is its no-argument constructor. You may decide to place a breakpoint there. You may also choose to stop in the  canIdentify()  method, which is appropriate for  processor plugins  such as this sample JavaScript parser.",
            "title": "Debugging setup: step-by-step"
        },
        {
            "location": "/dev/5-development-tips/index.html#launching-several-instances",
            "text": "JEB provides a fully customizable workspace area. Panels can be adjusted, stacked, minimized, expanded, etc. That data is persisted into a workspace folder.   You may have a need to to launch several instances of JEB, for instance because you have long processing on a first instance, and would like to continue investigating another task. If you try to launch a second instance, you are likely to see this error message:   This indicates a workspace conflict.  It is possible to launch a second (or more) instances of the JEB client by appending the  -data @none  parameters to the command line. Here, @none indicates that no workspace data shall be used or saved. (You may decide to persist that secondary workspace by providing a folder instead of @none.)  If you wish to modify your startup scripts to never record workspace layout data, and therefore have the ability to conveniently start as many instances of JEB as you'd like, here are the modifications to do:  On Linux/Mac OS:  $JAVA -jar $SCRIPTDIR/bin/cl/jeb.jar $@\nto \n$JAVA -data @none -jar $SCRIPTDIR/bin/cl/jeb.jar $@  On Windows:  %JAVA% -jar  %~dp0bin\\cl\\jeb.jar  %*\nto\n%JAVA% -data @none -jar  %~dp0bin\\cl\\jeb.jar  %*  Next:  Part 6",
            "title": "Launching several instances"
        },
        {
            "location": "/dev/6-releasing-plugin/index.html",
            "text": "JEB Plugin Development Tutorial part 6/8\n\n\nReleasing a Plugin\n\n\nWhen your plugin is ready, you may be looking into some way to share it. It is not convenient to hand out classfiles, not to mention changing Classpath and Classnames in the JEB \nOptions\n panel. The solution is to package your plugin: this page shows you how to build a jar file containing your JEB plugin.\n\n\nAnt Build File\n\n\nFirst, make sure to have a \nJEB_HOME\n environment variable pointing to your JEB directory. Then, use the following Ant \nbuild.xml\n file to build the sample JavaScript plugin.\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n standalone=\nno\n?\n\n\n\nproject basedir=\n.\n default=\nbuild\n name=\njebplugin\n\n    \nproperty name=\njebjar\n value=\n${env.JEB_HOME}/bin/cl/jeb.jar\n/\n\n    \nproperty name=\njebpath\n value=\n/home/clucas/jeb-2.0.6.201508260620/bin/cl/jeb.jar\n/\n\n    \nproperty name=\noutfile\n value=\nout/JebJavascriptPlugin.jar\n/\n\n    \nproperty name=\nentryclass\n value=\ncom.jeb.sample.JavascriptPlugin\n/\n\n\n    \nproperty name=\nextcp_build\n value=\nlib/js.jar\n/\n\n    \nproperty name=\nextcp_manifest\n value=\nlib/js.jar\n/\n\n\n    \ntarget name=\nbuild\n depends=\ncompile,package\n/\n\n\n    \ntarget name=\ncompile\n\n        \ndelete dir=\nbin\n/\n\n        \nmkdir dir=\nbin\n/\n\n        \njavac debug=\ntrue\n debuglevel=\nsource,lines,vars\n\n               destdir=\nbin\n includeantruntime=\nfalse\n source=\n1.7\n target=\n1.7\n\n            \nsrc path=\nsrc\n/\n\n            \nclasspath\n\n                \npathelement location=\n${jebpath}\n/\n\n                \npathelement path=\n${extcp_build}\n/\n\n            \n/classpath\n\n        \n/javac\n\n    \n/target\n\n\n    \ntarget name=\npackage\n\n        \ndelete file=\n${outfile}\n/\n\n        \njar destfile=\n${outfile}\n\n            \nmanifest\n\n                \nattribute name=\nClass-Path\n value=\n${extcp_manifest}\n/\n\n                \nattribute name=\nJebPlugin-entryclass\n value=\n${entryclass}\n/\n\n            \n/manifest\n\n            \nfileset dir=\nbin\n/\n\n            \nfileset dir=\n.\n includes=\nREADME.md\n/\n\n        \n/jar\n\n    \n/target\n\n\n\n/project\n\n\n\n\n\nBuilding the Plugin\n\n\nYou can run the build.xml directly from eclipse or execute the Ant command.\n\n\n\n\nIt will generate a jar which has 2 specific entries in the manifest:\n\n\n\n\nClass-Path\n to indicate the required external libraries.\n\n\nJebPlugin-entryclass\n to indicate the classname, ie your plugin entry-point\n\n\n\n\nCopy both JebJavascriptPlugin.jar and js.jar to your plugin folder. You can remove the classpath and classnames entries related to JavascriptPlugin and js.jar.\n\n\n\n\nNote\n: the best approach is to have one project per plugin.\n\n\n\n\nExercice: Split the project and generate JavascriptPlugin.jar and HashJavascriptPlugin.jar. Remove all classpaths and classnames to check that it works.\n\n\nGeneric Build Template\n\n\nThe following Ant template can be customized for your own plugins needs: \n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n standalone=\nno\n?\n\n\n\n!-- Sample Ant build file used to build and package a JEB plugin.\n- Requirements: set up the JEB_HOME environment variable to point to your\nJEB installation folder.\n- Customize the outfile, entryclass, extcp_build, and extcp_manifest properties. --\n\n\n\nproject basedir=\n.\n default=\nbuild\n name=\njebplugin\n\n\n    \nfail message=\nSet the plugin version number: ant -Dversion=x.y.z\n\n      \ncondition\n\n        \nnot\n\n          \nisset property=\nversion\n/\n\n        \n/not\n\n      \n/condition\n\n    \n/fail\n\n\n    \necho message=\nPlugin version: ${version}\n/\n\n\n    \nproperty environment=\nenv\n/\n\n    \necho message=\nJEB_HOME: ${env.JEB_HOME}\n/\n\n\n    \nproperty name=\njebjar\n value=\n${env.JEB_HOME}/bin/cl/jeb.jar\n/\n\n    \necho message=\nJEB Core expected at location: ${jebjar}\n/\n\n\n    \nfail message=\nPlease set JEB_HOME environment variable to point to your JEB installation folder\n\n      \ncondition\n\n        \nnot\n\n          \navailable file=\n${jebjar}\n/\n\n        \n/not\n\n      \n/condition\n\n    \n/fail\n\n\n    \nproperty name=\ndebuglevel\n value=\nsource,lines,vars\n/\n\n    \nproperty name=\ntarget\n value=\n1.7\n/\n\n    \nproperty name=\nsource\n value=\n1.7\n/\n\n\n    \n!-- Mandatory properties --\n\n    \nproperty name=\noutfile\n value=\nCUSTOMIZE\n/\n\n    \nproperty name=\nentryclass\n value=\nCUSTOMIZE\n/\n\n    \n!-- External libraries, for build process (semi-colon separated) --\n\n    \nproperty name=\nextcp_build\n value=\n/\n\n    \n!-- External libraries, for Manifest (space separated) --\n\n    \nproperty name=\nextcp_manifest\n value=\n/\n\n\n    \ntarget name=\nbuild\n depends=\nclean,compile,package\n/\n\n    \ntarget name=\naudit\n depends=\nclean,compile-audit\n/\n\n\n    \ntarget name=\nclean\n\n        \ndelete dir=\nbin\n/\n\n        \nmkdir dir=\nbin\n/\n\n    \n/target\n\n\n    \ntarget name=\ncompile\n\n        \ndelete dir=\nbin\n/\n\n        \nmkdir dir=\nbin\n/\n\n        \njavac debug=\ntrue\n debuglevel=\n${debuglevel}\n destdir=\nbin\n\n               includeantruntime=\nfalse\n source=\n${source}\n target=\n${target}\n encoding=\nUTF-8\n\n            \nsrc path=\nsrc/main/java\n/\n\n            \nclasspath\n\n                \npathelement location=\n${jebjar}\n/\n\n                \npathelement path=\n${extcp_build}\n/\n\n            \n/classpath\n\n        \n/javac\n\n    \n/target\n\n\n    \ntarget name=\npackage\n\n        \ndelete file=\n${outfile}\n/\n\n        \njar destfile=\n${outfile}\n\n            \nmanifest\n\n                \nattribute name=\nClass-Path\n value=\n${extcp_manifest}\n/\n\n                \nattribute name=\nJebPlugin-entryclass\n value=\n${entryclass}\n/\n\n                \nattribute name=\nJebPlugin-version\n value=\n${version}\n/\n\n            \n/manifest\n\n            \nfileset dir=\nbin\n/\n\n            \n!-- copy resources --\n\n            \nfileset dir=\nsrc/main/java\n excludes=\n**/*.java\n/\n\n            \nfileset dir=\n.\n includes=\nREADME.md\n/\n\n        \n/jar\n\n    \n/target\n\n\n\n/project\n\n\n\n\n\nNext: \nPart 7",
            "title": "Part 6: Releasing a Plugin"
        },
        {
            "location": "/dev/6-releasing-plugin/index.html#releasing-a-plugin",
            "text": "When your plugin is ready, you may be looking into some way to share it. It is not convenient to hand out classfiles, not to mention changing Classpath and Classnames in the JEB  Options  panel. The solution is to package your plugin: this page shows you how to build a jar file containing your JEB plugin.",
            "title": "Releasing a Plugin"
        },
        {
            "location": "/dev/6-releasing-plugin/index.html#ant-build-file",
            "text": "First, make sure to have a  JEB_HOME  environment variable pointing to your JEB directory. Then, use the following Ant  build.xml  file to build the sample JavaScript plugin.  ?xml version= 1.0  encoding= UTF-8  standalone= no ?  project basedir= .  default= build  name= jebplugin \n     property name= jebjar  value= ${env.JEB_HOME}/bin/cl/jeb.jar / \n     property name= jebpath  value= /home/clucas/jeb-2.0.6.201508260620/bin/cl/jeb.jar / \n     property name= outfile  value= out/JebJavascriptPlugin.jar / \n     property name= entryclass  value= com.jeb.sample.JavascriptPlugin / \n\n     property name= extcp_build  value= lib/js.jar / \n     property name= extcp_manifest  value= lib/js.jar / \n\n     target name= build  depends= compile,package / \n\n     target name= compile \n         delete dir= bin / \n         mkdir dir= bin / \n         javac debug= true  debuglevel= source,lines,vars \n               destdir= bin  includeantruntime= false  source= 1.7  target= 1.7 \n             src path= src / \n             classpath \n                 pathelement location= ${jebpath} / \n                 pathelement path= ${extcp_build} / \n             /classpath \n         /javac \n     /target \n\n     target name= package \n         delete file= ${outfile} / \n         jar destfile= ${outfile} \n             manifest \n                 attribute name= Class-Path  value= ${extcp_manifest} / \n                 attribute name= JebPlugin-entryclass  value= ${entryclass} / \n             /manifest \n             fileset dir= bin / \n             fileset dir= .  includes= README.md / \n         /jar \n     /target  /project",
            "title": "Ant Build File"
        },
        {
            "location": "/dev/6-releasing-plugin/index.html#building-the-plugin",
            "text": "You can run the build.xml directly from eclipse or execute the Ant command.   It will generate a jar which has 2 specific entries in the manifest:   Class-Path  to indicate the required external libraries.  JebPlugin-entryclass  to indicate the classname, ie your plugin entry-point   Copy both JebJavascriptPlugin.jar and js.jar to your plugin folder. You can remove the classpath and classnames entries related to JavascriptPlugin and js.jar.   Note : the best approach is to have one project per plugin.   Exercice: Split the project and generate JavascriptPlugin.jar and HashJavascriptPlugin.jar. Remove all classpaths and classnames to check that it works.",
            "title": "Building the Plugin"
        },
        {
            "location": "/dev/6-releasing-plugin/index.html#generic-build-template",
            "text": "The following Ant template can be customized for your own plugins needs:   ?xml version= 1.0  encoding= UTF-8  standalone= no ?  !-- Sample Ant build file used to build and package a JEB plugin.\n- Requirements: set up the JEB_HOME environment variable to point to your\nJEB installation folder.\n- Customize the outfile, entryclass, extcp_build, and extcp_manifest properties. --  project basedir= .  default= build  name= jebplugin \n\n     fail message= Set the plugin version number: ant -Dversion=x.y.z \n       condition \n         not \n           isset property= version / \n         /not \n       /condition \n     /fail \n\n     echo message= Plugin version: ${version} / \n\n     property environment= env / \n     echo message= JEB_HOME: ${env.JEB_HOME} / \n\n     property name= jebjar  value= ${env.JEB_HOME}/bin/cl/jeb.jar / \n     echo message= JEB Core expected at location: ${jebjar} / \n\n     fail message= Please set JEB_HOME environment variable to point to your JEB installation folder \n       condition \n         not \n           available file= ${jebjar} / \n         /not \n       /condition \n     /fail \n\n     property name= debuglevel  value= source,lines,vars / \n     property name= target  value= 1.7 / \n     property name= source  value= 1.7 / \n\n     !-- Mandatory properties -- \n     property name= outfile  value= CUSTOMIZE / \n     property name= entryclass  value= CUSTOMIZE / \n     !-- External libraries, for build process (semi-colon separated) -- \n     property name= extcp_build  value= / \n     !-- External libraries, for Manifest (space separated) -- \n     property name= extcp_manifest  value= / \n\n     target name= build  depends= clean,compile,package / \n     target name= audit  depends= clean,compile-audit / \n\n     target name= clean \n         delete dir= bin / \n         mkdir dir= bin / \n     /target \n\n     target name= compile \n         delete dir= bin / \n         mkdir dir= bin / \n         javac debug= true  debuglevel= ${debuglevel}  destdir= bin \n               includeantruntime= false  source= ${source}  target= ${target}  encoding= UTF-8 \n             src path= src/main/java / \n             classpath \n                 pathelement location= ${jebjar} / \n                 pathelement path= ${extcp_build} / \n             /classpath \n         /javac \n     /target \n\n     target name= package \n         delete file= ${outfile} / \n         jar destfile= ${outfile} \n             manifest \n                 attribute name= Class-Path  value= ${extcp_manifest} / \n                 attribute name= JebPlugin-entryclass  value= ${entryclass} / \n                 attribute name= JebPlugin-version  value= ${version} / \n             /manifest \n             fileset dir= bin / \n             !-- copy resources -- \n             fileset dir= src/main/java  excludes= **/*.java / \n             fileset dir= .  includes= README.md / \n         /jar \n     /target  /project   Next:  Part 7",
            "title": "Generic Build Template"
        },
        {
            "location": "/dev/7-unit-interactivity/index.html",
            "text": "JEB Plugin Development Tutorial part 7/8\n\n\nUnit Interactivity\n\n\nThe source code for part 7 of this sample plugin is located on GitHub:\n\n\n\n\nClone \nthis repo\n: \ngit clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git\n\n\nSwitch to the \ntutorial7\n branch: \ngit checkout tutorial7\n\n\n\n\nSyntax Highlighting\n\n\nLet's dive deeper and implement the first thing we want to get from an editor: syntax highlighting. This will allow us to uncover more corners of the JEB API.\n\n\nWe will need to add item highlights on some parts of the text. Remember our sample, we will use only a single part:\n\n\nfunction a() {\n  alert(\na called\n);\n}\n\n\n\n\nA standard editor highlights keywords: they are specific words (reserved, most of the time) that are related to a language. In JavaScript, they are \"function\", \"var\", \"if\", \"else\"... Other interesting artifacts that could be highlighted are strings. In this tutorial, we will highlight functions, variables and strings surrounded by double-quotes.\n\n\nWe want to modify only the display, not interact with the model (eg, renaming, formatting), so we will only look at \nITextDocument\n. It has two important features:\n\n\n\n\nit builds \nITextDocumentPart\n\n\nit has a \ncoordinate to/from address\n conversion system. We will see this later.\n\n\n\n\nLet's concentrate on the \nITextDocumentPart\n. The interface defines two methods:\n\n\n\n\none returns a list of \nILine\n objects: the part is split into lines.\n\n\nthe other one returns a list of \nIAnchor\n objects. Anchors act the same as chapters for a book: an anchor indicates the beginning of a new section. If you don't need it, you can use a single anchor for the entire document.\n\n\n\n\nRemember that a part represents a part of the document (for buffered document) or can include the whole document. So the list of lines can be all the lines or just the lines of a part. We won't treat buffered document in this tutorial to keep things simple.\n\n\nOnce again, let's check only the most important object, \nILine\n. It contains:\n\n\n\n\na \nCharSequence\n: the text line\n\n\na List of \nITextItem\n. As said in the API: A text item is used to identify a particular sequence of characters. This looks like what we were looking for.\n\n\n\n\nWe will need to add \nITextItem\n to our current model. The \nTextItem\n default implementation can be used. It takes as argument:\n\n\n\n\nthe start offset of the keyword\n\n\nthe length of the keyword\n\n\nan \nItemClassIdentifiers\n identifier to apply a specific semantic and eventually, style, to your element. You can configure the display of these styles in the \nEdit, Fonts and Style...\n panel.\n\n\n\n\n\n\nAssignment 1\n: Clone the sample code and checkout the \ntutorial7\n branch. It already displays functions using a special ItemClassIdentifiers. Try to do the same for the \nvar\n keyword and string constants.\n\n\n\n\n\n\nNotifications\n\n\nJEB is a security-oriented product: its aim is to help you analyze malicious code and pin-point potential areas of interest. \nNotifications\n can be used to show areas that are noteworthy; styles can be attached to notifications to highlight their corresponding elements on rendering. Notifications are global to a unit, they should be generated whe the processor plugin \nprocess()\n-es the input.\n\n\nFor the sake of this tutorial, we want to highlight the usage of function \"alert\" because it can block the UI unreasonably.\n\n\nThe \nAbstractUnit\n interface exposes the following method:\n\n\npublic addtNotifications(IUnitNotification unit);\n\n\n\n\nWe will use the default implementation: \nUnitNotification\n.\n\n\nIn the \nprocess()\n method of your JavaScript plugin, add the following snippet:\n\n\nroot.visit(new NodeVisitor() {\n    @Override\n    public boolean visit(AstNode node) {\n        switch(node.getType()) {\n        case Token.EXPR_VOID:\n        case Token.EXPR_RESULT:\n            break;\n        case Token.CALL:\n            visitTarget(((FunctionCall)node).getTarget());\n            break;\n        default:\n            break;\n        }\n    return true;\n    }\n\n    private void visitTarget(AstNode target) {\n        if(target.getType() == Token.NAME) {\n            if(((Name)target).getIdentifier().equals(\nalert\n)) {\n                // Add notification\n                addNotification(new UnitNotification(NotificationType.POTENTIALLY_HARMFUL,\n                        String.format(\nalert is detected at position %d\n, target.getAbsolutePosition())));\n            }\n        }\n    }\n});\n\n\n\n\nThe \nvisit()\n method recursively process all the elements. When we have a JavaScript function call, we check the name and add a notification if the function is \"alert\".\n\n\nNow, you should see something new in the UI:\n\n\n\n\nIf you want to see all notifications as soon as the file is opened in JEB, you will need to slightly modify your code. Since the \nprocess()\n method is only called on opening an IUnit, the best is to call it directly after IUnit creation:\n\n\npublic IUnit prepare(String name, IInput input, IUnitProcessor unitProcessor, IUnitCreator parent) {\n    IUnit sampleUnit = new SampleUnit(name, input, unitProcessor, parent, pdm);\n    sampleUnit.process(); // forces children calculation\n    return sampleUnit;\n}\n\n\n\n\nAlways be careful to add this line somewhere in the process() method to indicate that the processing should not be done once again:\n\n\nsetProcessed(true);\n\n\n\n\nNow, we see something interesting on the screenshot: there is an address column that is blank. \nIUnitNotification\n defines an address binding which can be used to jump to the related section. Let's see how to use it.\n\n\nAddressing\n\n\nTo be able to jump to a correct \nAddress\n, we need to define a binding from Unit addressing (address) to a position in a Document (coordinates).\n\n\nITextDocument uses \nICoordinates\n: it contains the anchor id, a line number relative to the anchor, and the position (column offset) in the line.\n\n\nAddresses, however, are user-defined (in this context, the user is the plugin developer): it is up to user to define them and their granularity. For instance, you can choose to support addresses:\n\n\n\n\nat function level/ element level. For example: \"function a\", \"function a / statement 1\"\n\n\nat byte level. For example, using absolute byte address in file: \"0x1A\", \"0x89\"\n\n\nat any other level. For example, at each line, each character for that line, etc.\n\n\n\n\nThe important aspect of addresses is that an address must not be directly tied to a Document (your implementation of Document can change: if you add a beautifier, if you decide to format your document on a single line, if you use a tree/table for your representation, etc.). Of course, there should still be a way to make the link between the two addressing systems:\n\n\n\n\nRefer to the technical draft \n\"Positioning within inputs, units, and documents\"\n for additional details on addressing.\n\n\n\n\nAt last, an address must identify an object/position in a unique way. Otherwise, you wouldn't know where to jump.\n\n\nFor our sample JavaScript plugin, we will use the addressing using \nAstNode.getAbsolutePosition()\n. When jumping from Notification Panel, we have the current address (Absolute position), and we will jump to an ICoordinates in the ITextDocument. So the main method to implement is:\n\n\npublic ICoordinates addressToCoordinates(String address);\n\n\n\n\nAssignment 2\n: Try to implement this method.\n\n\n\n\nThere is also another column in the Notification Panel called \"Label\": it represents the label of the address. You can indicate here a human readable label: for example, the name of the function.\n\n\nTo display label, we need to inherit from \nIInteractiveUnit\n and implement String getAddressLabel(String address) to see changes in the Notification Panel.\n\n\n\n\nAssignment 3 (hard)\n: Try to implement the getAddressLabel() method.\n\n\n\n\nA solution to the assignments can be found by checking out the branch \ntutorial7_solution\n of the \nsample code\n. \n\n\nYou may have noticed that IInteractiveUnit provides a lot of methods. We will focus on it in the next part!\n\n\nNext: \nPart 8",
            "title": "Part 7: Interactivity"
        },
        {
            "location": "/dev/7-unit-interactivity/index.html#unit-interactivity",
            "text": "The source code for part 7 of this sample plugin is located on GitHub:   Clone  this repo :  git clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git  Switch to the  tutorial7  branch:  git checkout tutorial7",
            "title": "Unit Interactivity"
        },
        {
            "location": "/dev/7-unit-interactivity/index.html#syntax-highlighting",
            "text": "Let's dive deeper and implement the first thing we want to get from an editor: syntax highlighting. This will allow us to uncover more corners of the JEB API.  We will need to add item highlights on some parts of the text. Remember our sample, we will use only a single part:  function a() {\n  alert( a called );\n}  A standard editor highlights keywords: they are specific words (reserved, most of the time) that are related to a language. In JavaScript, they are \"function\", \"var\", \"if\", \"else\"... Other interesting artifacts that could be highlighted are strings. In this tutorial, we will highlight functions, variables and strings surrounded by double-quotes.  We want to modify only the display, not interact with the model (eg, renaming, formatting), so we will only look at  ITextDocument . It has two important features:   it builds  ITextDocumentPart  it has a  coordinate to/from address  conversion system. We will see this later.   Let's concentrate on the  ITextDocumentPart . The interface defines two methods:   one returns a list of  ILine  objects: the part is split into lines.  the other one returns a list of  IAnchor  objects. Anchors act the same as chapters for a book: an anchor indicates the beginning of a new section. If you don't need it, you can use a single anchor for the entire document.   Remember that a part represents a part of the document (for buffered document) or can include the whole document. So the list of lines can be all the lines or just the lines of a part. We won't treat buffered document in this tutorial to keep things simple.  Once again, let's check only the most important object,  ILine . It contains:   a  CharSequence : the text line  a List of  ITextItem . As said in the API: A text item is used to identify a particular sequence of characters. This looks like what we were looking for.   We will need to add  ITextItem  to our current model. The  TextItem  default implementation can be used. It takes as argument:   the start offset of the keyword  the length of the keyword  an  ItemClassIdentifiers  identifier to apply a specific semantic and eventually, style, to your element. You can configure the display of these styles in the  Edit, Fonts and Style...  panel.    Assignment 1 : Clone the sample code and checkout the  tutorial7  branch. It already displays functions using a special ItemClassIdentifiers. Try to do the same for the  var  keyword and string constants.",
            "title": "Syntax Highlighting"
        },
        {
            "location": "/dev/7-unit-interactivity/index.html#notifications",
            "text": "JEB is a security-oriented product: its aim is to help you analyze malicious code and pin-point potential areas of interest.  Notifications  can be used to show areas that are noteworthy; styles can be attached to notifications to highlight their corresponding elements on rendering. Notifications are global to a unit, they should be generated whe the processor plugin  process() -es the input.  For the sake of this tutorial, we want to highlight the usage of function \"alert\" because it can block the UI unreasonably.  The  AbstractUnit  interface exposes the following method:  public addtNotifications(IUnitNotification unit);  We will use the default implementation:  UnitNotification .  In the  process()  method of your JavaScript plugin, add the following snippet:  root.visit(new NodeVisitor() {\n    @Override\n    public boolean visit(AstNode node) {\n        switch(node.getType()) {\n        case Token.EXPR_VOID:\n        case Token.EXPR_RESULT:\n            break;\n        case Token.CALL:\n            visitTarget(((FunctionCall)node).getTarget());\n            break;\n        default:\n            break;\n        }\n    return true;\n    }\n\n    private void visitTarget(AstNode target) {\n        if(target.getType() == Token.NAME) {\n            if(((Name)target).getIdentifier().equals( alert )) {\n                // Add notification\n                addNotification(new UnitNotification(NotificationType.POTENTIALLY_HARMFUL,\n                        String.format( alert is detected at position %d , target.getAbsolutePosition())));\n            }\n        }\n    }\n});  The  visit()  method recursively process all the elements. When we have a JavaScript function call, we check the name and add a notification if the function is \"alert\".  Now, you should see something new in the UI:   If you want to see all notifications as soon as the file is opened in JEB, you will need to slightly modify your code. Since the  process()  method is only called on opening an IUnit, the best is to call it directly after IUnit creation:  public IUnit prepare(String name, IInput input, IUnitProcessor unitProcessor, IUnitCreator parent) {\n    IUnit sampleUnit = new SampleUnit(name, input, unitProcessor, parent, pdm);\n    sampleUnit.process(); // forces children calculation\n    return sampleUnit;\n}  Always be careful to add this line somewhere in the process() method to indicate that the processing should not be done once again:  setProcessed(true);  Now, we see something interesting on the screenshot: there is an address column that is blank.  IUnitNotification  defines an address binding which can be used to jump to the related section. Let's see how to use it.",
            "title": "Notifications"
        },
        {
            "location": "/dev/7-unit-interactivity/index.html#addressing",
            "text": "To be able to jump to a correct  Address , we need to define a binding from Unit addressing (address) to a position in a Document (coordinates).  ITextDocument uses  ICoordinates : it contains the anchor id, a line number relative to the anchor, and the position (column offset) in the line.  Addresses, however, are user-defined (in this context, the user is the plugin developer): it is up to user to define them and their granularity. For instance, you can choose to support addresses:   at function level/ element level. For example: \"function a\", \"function a / statement 1\"  at byte level. For example, using absolute byte address in file: \"0x1A\", \"0x89\"  at any other level. For example, at each line, each character for that line, etc.   The important aspect of addresses is that an address must not be directly tied to a Document (your implementation of Document can change: if you add a beautifier, if you decide to format your document on a single line, if you use a tree/table for your representation, etc.). Of course, there should still be a way to make the link between the two addressing systems:   Refer to the technical draft  \"Positioning within inputs, units, and documents\"  for additional details on addressing.   At last, an address must identify an object/position in a unique way. Otherwise, you wouldn't know where to jump.  For our sample JavaScript plugin, we will use the addressing using  AstNode.getAbsolutePosition() . When jumping from Notification Panel, we have the current address (Absolute position), and we will jump to an ICoordinates in the ITextDocument. So the main method to implement is:  public ICoordinates addressToCoordinates(String address);   Assignment 2 : Try to implement this method.   There is also another column in the Notification Panel called \"Label\": it represents the label of the address. You can indicate here a human readable label: for example, the name of the function.  To display label, we need to inherit from  IInteractiveUnit  and implement String getAddressLabel(String address) to see changes in the Notification Panel.   Assignment 3 (hard) : Try to implement the getAddressLabel() method.   A solution to the assignments can be found by checking out the branch  tutorial7_solution  of the  sample code .   You may have noticed that IInteractiveUnit provides a lot of methods. We will focus on it in the next part!  Next:  Part 8",
            "title": "Addressing"
        },
        {
            "location": "/dev/8-more-interactivity/index.html",
            "text": "JEB Plugin Development Tutorial part 8/8\n\n\nMore on Interactivity\n\n\nThe source code for part 8 of this sample plugin is located on GitHub:\n\n\n\n\nClone \nthis repo\n: \ngit clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git\n\n\nSwitch to the \ntutorial8\n branch: \ngit checkout tutorial8\n\n\n\n\nUser Actions\n\n\nCanExecute\n\n\nJEB provides the ability to interact with the units. Those units are called \ninteractive units\n.\n\n\nThe simplest way to interact with units is through \nwell-known actions\n.\n\n\n\n\nThe actions have to be implemented by the plugin developer. An action has an \nActionContext\n as a parameter, which allows the plugin to retrieve:\n\n\n\n\nthe action id: one defined in the \nActions\n class. It indicates which action is involved (Comment, Rename...)\n\n\nthe address: the current position in the document\n\n\nthe item id: we will discuss it later.\n\n\n\n\nFirst, why are all these actions grayed out? Because \ncanExecuteAction()\n does not return true - yet.\n\n\npublic boolean canExecuteAction(ActionContext actionContext) {\n    logger.info(\n%s called with address %s and actionId %d\n,\n            \ncanExecuteAction\n, actionContext.getAddress(), actionContext.getActionId());\n    return false;\n}\n\n\n\n\nAs you can see in the logs, this method is called each time you move the caret in the document. What if we try to return true instead of false?\n\n\n\n\nAs expected, all actions become clickable.\n\n\nNote that you can also use the toolbar icons or, even better, the keyboard shortcuts.\n\n\n\n\nNothing happens when you click on any action: it is up to the plugin developer to implement the desired feature.\n\n\nWe will implement a simple action: \nrenaming of a String\n. (Note: we could as well rename functions, methods, variables... but we need to check in the model where they are used to replace all occurrences, consistently. The added complexity is out-of-scope in this API introduction tutorial.)\n\n\nFirst, we need to activate the rename feature when we are on a String:\n\n\n\n\nAssignment 1\n: Save the string references and test if the caret in on a String.\n\n\n\n\nPrepareExecution\n\n\nWhen clicking on the \"Rename\" action button, the method \nIInteractiveUnit.prepareExecution()\n is called. Its goal is to prepare the execution of the code and, in the case of renaming, it also provides the initial value that we want to edit: it is called before displaying the following pop up:\n\n\n\n\nYou need to return true in the prepareExecution method to indicate that the processing should continue.\n\n\nThe \nprepareExecution\n method has one more parameter of type \nIActionData\n. To fill up the name field, we need to retrieve the correct Action Data type:\n\n\n\n\nUse \nActionRenameData\n to prefill the rename field with its current value.\n\n\npublic boolean prepareExecution(ActionContext actionContext, IActionData actionData) {\n    if(actionContext.getActionId() == Actions.RENAME) {\n        StringLiteral string = getElementAt(actionContext.getAddress(), strings);\n        if(string != null) {\n            ((ActionRenameData)actionData).setCurrentName(string.getValue());\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\n\nNote that IActionData embeds a generic map to pass discretionary objects from \nprepareExecution\n to \nexecuteAction\n method.\n\n\nExecuteAction\n\n\nThe executeAction method is the last step: it performs the action and modifies the model.\n\n\nWhat should we modify now?\n\n\n\n\nIInput\n: this is a pointer to original file, it makes no sense.\n\n\nAstRoot\n: this is our kind-of model, but there is no way to retrieve the input data (the toString() method has a specific implementation and the toSource() auto-formats and remove comments.\n\n\n\n\nIUnit\n is the central part of your plugin: it is responsible for updating the model and keep coherence regarding all its document. But there is something wrong with the initial design: we don't save a reference Document in the Unit.\n\n\nDocuments shall at least work with the same object as IUnit, and at least have a reference on their IUnit in order to retrieve the data (this is a good practice in JEB).\n\n\nTherefore, we will now modify our unit to keep references of all lines (using a List\n).\nOne problem that will remain is the mandatory conversion at the \nITextDocumentPart\n level:\n\n\npublic List\n? extends ILine\n getLines\n\n\n\n\nThe \ngetLines\n method is called each time you scroll/move around the document, so it would be too costly to recalculate the list of ILines each time it is called. It must be buffered and refreshed on changes: the unit must notify its Documents when the model changes.\n\n\nTo make notifications work, you must:\n\n\n\n\nRegister the notified element:\n\n\n\n\npublic class JavascriptDocument extends EventSource implements ITextDocument, IEventListener {\n    public JavascriptDocument(JavascriptUnit unit) {\n        this.unit = unit;\n        unit.addListener(this);\n        refreshPart();\n    }\n\n    // ...\n\n    public void onEvent(IEvent e) {\n        if(e.getType() == J.UnitChange) {\n            refreshPart();\n            this.notifyListeners(e);\n        }\n    }\n}\n\n\n\n\n\n\nCall the notify method in the executeAction method (on success):\n\n\n\n\nnotifyListeners(new JebEvent(J.UnitChange));\n\n\n\n\n\n\nRefer to the technical draft \n\"Staying informed of unit changes\"\n for more details about unit changes tracking within documents.\n\n\nAssignment 2\n: Finish the renaming implementation.\n\n\n\n\nNavigation\n\n\nJEB natively manages navigation feature with four predefined actions selectable from menu or directly with shortcuts:\n\n\n\n\n\n\nJump To\n: move caret to a specific address. It uses the \nITextDocument.addressToCoordinates()\n that we already implemented for Notifications.\n\n\nNavigate Forward / Navigate Backward\n: move caret to the previous/next position (caret position history is saved each time you jump)\n\n\nFollow\n: jump to an address bound to the current element. The best example is on a function call: you can jump to its definition\n\n\n\n\n\n\nAssignment 3\n: Implement Jump To for function names\n\n\n\n\nNow, let's look at Follow. We can see that it is active only when we set the caret on strings, var, function... this is because the Follow feature is bound to Items, more precisely, the \nIActionableItem\n.\n\n\nWhen clicking on \nFollow\n, if the caret is positioned on an Item, the function \nIInteractiveUnit.getAddressOfItem()\n is called.\n\n\n\n\nAssignment 4\n: Implement Follow for function name (it should work on the latest b();)\n\n\n\n\nA solution to the assignments can be found by checking out the branch \ntutorial8\n of the \nsample code\n. \n\n\nBack to \nPart 1",
            "title": "Part 8: More on Interactivity"
        },
        {
            "location": "/dev/8-more-interactivity/index.html#more-on-interactivity",
            "text": "The source code for part 8 of this sample plugin is located on GitHub:   Clone  this repo :  git clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git  Switch to the  tutorial8  branch:  git checkout tutorial8",
            "title": "More on Interactivity"
        },
        {
            "location": "/dev/8-more-interactivity/index.html#user-actions",
            "text": "",
            "title": "User Actions"
        },
        {
            "location": "/dev/8-more-interactivity/index.html#canexecute",
            "text": "JEB provides the ability to interact with the units. Those units are called  interactive units .  The simplest way to interact with units is through  well-known actions .   The actions have to be implemented by the plugin developer. An action has an  ActionContext  as a parameter, which allows the plugin to retrieve:   the action id: one defined in the  Actions  class. It indicates which action is involved (Comment, Rename...)  the address: the current position in the document  the item id: we will discuss it later.   First, why are all these actions grayed out? Because  canExecuteAction()  does not return true - yet.  public boolean canExecuteAction(ActionContext actionContext) {\n    logger.info( %s called with address %s and actionId %d ,\n             canExecuteAction , actionContext.getAddress(), actionContext.getActionId());\n    return false;\n}  As you can see in the logs, this method is called each time you move the caret in the document. What if we try to return true instead of false?   As expected, all actions become clickable.  Note that you can also use the toolbar icons or, even better, the keyboard shortcuts.   Nothing happens when you click on any action: it is up to the plugin developer to implement the desired feature.  We will implement a simple action:  renaming of a String . (Note: we could as well rename functions, methods, variables... but we need to check in the model where they are used to replace all occurrences, consistently. The added complexity is out-of-scope in this API introduction tutorial.)  First, we need to activate the rename feature when we are on a String:   Assignment 1 : Save the string references and test if the caret in on a String.",
            "title": "CanExecute"
        },
        {
            "location": "/dev/8-more-interactivity/index.html#prepareexecution",
            "text": "When clicking on the \"Rename\" action button, the method  IInteractiveUnit.prepareExecution()  is called. Its goal is to prepare the execution of the code and, in the case of renaming, it also provides the initial value that we want to edit: it is called before displaying the following pop up:   You need to return true in the prepareExecution method to indicate that the processing should continue.  The  prepareExecution  method has one more parameter of type  IActionData . To fill up the name field, we need to retrieve the correct Action Data type:   Use  ActionRenameData  to prefill the rename field with its current value.  public boolean prepareExecution(ActionContext actionContext, IActionData actionData) {\n    if(actionContext.getActionId() == Actions.RENAME) {\n        StringLiteral string = getElementAt(actionContext.getAddress(), strings);\n        if(string != null) {\n            ((ActionRenameData)actionData).setCurrentName(string.getValue());\n            return true;\n        }\n    }\n    return false;\n}  Note that IActionData embeds a generic map to pass discretionary objects from  prepareExecution  to  executeAction  method.",
            "title": "PrepareExecution"
        },
        {
            "location": "/dev/8-more-interactivity/index.html#executeaction",
            "text": "The executeAction method is the last step: it performs the action and modifies the model.  What should we modify now?   IInput : this is a pointer to original file, it makes no sense.  AstRoot : this is our kind-of model, but there is no way to retrieve the input data (the toString() method has a specific implementation and the toSource() auto-formats and remove comments.   IUnit  is the central part of your plugin: it is responsible for updating the model and keep coherence regarding all its document. But there is something wrong with the initial design: we don't save a reference Document in the Unit.  Documents shall at least work with the same object as IUnit, and at least have a reference on their IUnit in order to retrieve the data (this is a good practice in JEB).  Therefore, we will now modify our unit to keep references of all lines (using a List ).\nOne problem that will remain is the mandatory conversion at the  ITextDocumentPart  level:  public List ? extends ILine  getLines  The  getLines  method is called each time you scroll/move around the document, so it would be too costly to recalculate the list of ILines each time it is called. It must be buffered and refreshed on changes: the unit must notify its Documents when the model changes.  To make notifications work, you must:   Register the notified element:   public class JavascriptDocument extends EventSource implements ITextDocument, IEventListener {\n    public JavascriptDocument(JavascriptUnit unit) {\n        this.unit = unit;\n        unit.addListener(this);\n        refreshPart();\n    }\n\n    // ...\n\n    public void onEvent(IEvent e) {\n        if(e.getType() == J.UnitChange) {\n            refreshPart();\n            this.notifyListeners(e);\n        }\n    }\n}   Call the notify method in the executeAction method (on success):   notifyListeners(new JebEvent(J.UnitChange));   Refer to the technical draft  \"Staying informed of unit changes\"  for more details about unit changes tracking within documents.  Assignment 2 : Finish the renaming implementation.",
            "title": "ExecuteAction"
        },
        {
            "location": "/dev/8-more-interactivity/index.html#navigation",
            "text": "JEB natively manages navigation feature with four predefined actions selectable from menu or directly with shortcuts:    Jump To : move caret to a specific address. It uses the  ITextDocument.addressToCoordinates()  that we already implemented for Notifications.  Navigate Forward / Navigate Backward : move caret to the previous/next position (caret position history is saved each time you jump)  Follow : jump to an address bound to the current element. The best example is on a function call: you can jump to its definition    Assignment 3 : Implement Jump To for function names   Now, let's look at Follow. We can see that it is active only when we set the caret on strings, var, function... this is because the Follow feature is bound to Items, more precisely, the  IActionableItem .  When clicking on  Follow , if the caret is positioned on an Item, the function  IInteractiveUnit.getAddressOfItem()  is called.   Assignment 4 : Implement Follow for function name (it should work on the latest b();)   A solution to the assignments can be found by checking out the branch  tutorial8  of the  sample code .   Back to  Part 1",
            "title": "Navigation"
        },
        {
            "location": "/dev/writing-engines-plugins/index.html",
            "text": "Writing Engines Plugins\n\n\nEngines plugins, just like any JEB extension (parser, script, etc.) use the JEB API.\n\n\nThey are loaded when JEB starts. Unlike parsers, their role is not to process input data to produce units; they are meant to perform pointed tasks. They can be called on-demand by clients.\n\n\nFrom a programmer's standpoint, engines plugins extend the \nIEnginesPlugin\n (whereas processor plugins extend the \nIUnitIdentifier\n interface).\n\n\nSample Plugins\n\n\nSample plugins can be found on our GitHub account. Examples:\n\n\n\n\nAndhook\n: Android Cryptographic Primitives Hooking using the JEB Debuggers API\n\n\n... \n\n\n\n\nSkeleton Plugin\n\n\nFull source code: \nSample plugin skeleton on GitHub\n\n\npublic class SampleEnginesPlugin implements IEnginesPlugin {\n    private static final ILogger logger = GlobalLog.getLogger(SampleEnginesPlugin.class);\n\n    @Override\n    public IPluginInformation getPluginInformation() {\n        return new PluginInformation(\nSample Plugin\n, \nA sample JEB2 plugin\n, \nPNF Software\n, Version.create(1, 0));\n    }\n\n    @Override\n    public List\n? extends IOptionDefinition\n getExecutionOptionDefinitions() {\n        return null;\n    }\n\n    @Override\n    public void execute(IEnginesContext context) {\n        execute(context, null);\n    }\n\n    @Override\n    public void execute(IEnginesContext engctx, Map\nString, String\n executionOptions) {\n        logger.info(\nExecuting sample plugin\n);\n    }\n\n    @Override\n    public void dispose() {\n    }\n}",
            "title": "Writing Engines Plugins"
        },
        {
            "location": "/dev/writing-engines-plugins/index.html#writing-engines-plugins",
            "text": "Engines plugins, just like any JEB extension (parser, script, etc.) use the JEB API.  They are loaded when JEB starts. Unlike parsers, their role is not to process input data to produce units; they are meant to perform pointed tasks. They can be called on-demand by clients.  From a programmer's standpoint, engines plugins extend the  IEnginesPlugin  (whereas processor plugins extend the  IUnitIdentifier  interface).",
            "title": "Writing Engines Plugins"
        },
        {
            "location": "/dev/writing-engines-plugins/index.html#sample-plugins",
            "text": "Sample plugins can be found on our GitHub account. Examples:   Andhook : Android Cryptographic Primitives Hooking using the JEB Debuggers API  ...",
            "title": "Sample Plugins"
        },
        {
            "location": "/dev/writing-engines-plugins/index.html#skeleton-plugin",
            "text": "Full source code:  Sample plugin skeleton on GitHub  public class SampleEnginesPlugin implements IEnginesPlugin {\n    private static final ILogger logger = GlobalLog.getLogger(SampleEnginesPlugin.class);\n\n    @Override\n    public IPluginInformation getPluginInformation() {\n        return new PluginInformation( Sample Plugin ,  A sample JEB2 plugin ,  PNF Software , Version.create(1, 0));\n    }\n\n    @Override\n    public List ? extends IOptionDefinition  getExecutionOptionDefinitions() {\n        return null;\n    }\n\n    @Override\n    public void execute(IEnginesContext context) {\n        execute(context, null);\n    }\n\n    @Override\n    public void execute(IEnginesContext engctx, Map String, String  executionOptions) {\n        logger.info( Executing sample plugin );\n    }\n\n    @Override\n    public void dispose() {\n    }\n}",
            "title": "Skeleton Plugin"
        },
        {
            "location": "/dev/writing-front-ends/index.html",
            "text": "Writing Front-Ends\n\n\nJEB front-end are also referred to as \"JEB clients\" (or \"JEB third-party clients\", to contrast with the \"official RCP desktop client\").\n\n\nJEB back-end API makes writing new clients (aka, front-ends) an easy task. A client can be:\n\n\n\n\nAn automated client (for testing, for an automation pipeline)\n\n\nA command-line client\n\n\nA graphical front-end (eg, the official RCP desktop client)\n\n\n...\n\n\n\n\n\n\nNote:\n Not all JEB licenses allow the creation of third-party clients. Verify this by checking your license information in the About dialog box. It should show \nany-client\n. Typically, \nJEB Pro\n licenses allow the execution of third-party clients.\n\n\n\n\nHigh-level Instructions\n\n\nUse the provided source code template (see below) as a base for your client. The basic steps any client should take are the following:\n\n\n\n\nUse \nJebCoreService\n to retrieve an instance to \nICoreContext\n\n\nCreate an \nIEnginesContext\n\n\nLoad a project within that context (\nIRuntimeProject\n)\n\n\nAdd artifacts and process them (\nILiveArtifact\n)\n\n\nRetrieve the products (\nIUnit\n)\n\n\nProceed as usual with the units\n\n\nWe recommend developers to read \nour tutorial series\n on parser development to get familiar with units\n\n\n\n\n\n\n\n\nRefer to the our \nsimplified architecture diagrams\n to better visualize how those components are connected to one another.\n\n\nSource Template\n\n\nFull source code: \nCommand-line client skeleton on GitHub\n\n\npublic class AutoClient {\n    static final ILogger logger = GlobalLog.getLogger(AutoClient.class);\n    static {\n        GlobalLog.addDestinationStream(System.out);\n    }\n\n    // TODO: customize (should be replaced by the LicenseKey entry in your bin/jeb-client.cfg file)\n    private static final String licenseKey = \n...\n;\n\n    // TODO: customize\n    private static final String baseDir = \n...\n;\n\n    public static void main(String[] argv) throws Exception {\n        if(argv.length \n= 0) {\n            return;\n        }\n\n        long t0 = System.currentTimeMillis();\n        String location = argv[0];\n        List\nFile\n files = AutoUtil.retrieveFiles(location);\n        test(files);\n        logger.info(\nDone in %ds\n, (System.currentTimeMillis() - t0) / 1000);\n    }\n\n    /**\n     * Initialize a core. Create a context within that core. Then, for each input artifact, a\n     * project is created and the artifact is loaded within that project.\n     */\n    public static void test(List\nFile\n files) throws Exception {\n        // create or retrieve a core context (engines container)\n        ICoreContext core = JebCoreService.getInstance(licenseKey);\n\n        // create an engines context (project container)\n        IFileDatabase projectdb = new JEB2FileDatabase(baseDir);\n        IFileStore filestore = new SimpleFSFileStore(baseDir);\n        BaseConfiguration cfg = new BaseConfiguration();\n\n        // TODO: customize (alternative is to read your configuration from .cfg file)\n        cfg.setProperty(\n.DevPluginClasspath\n, \n...\n);\n\n        // TODO: customize\n        cfg.setProperty(\n.DevPluginClassnames\n, \n...\n);\n\n        IConfiguration config = new CommonsConfigurationWrapper(cfg);\n        IDataProvider dataProvider = new DataProvider(null, projectdb, filestore, null, null, config);\n        IEnginesContext engctx = core.createEnginesContext(dataProvider, null);\n\n        int i = 0;\n        for(File file: files) {\n            i++;\n            logger.info(\nTesting file %d/%d : %s ...\n, i, files.size(), file.getName());\n\n            // create or load a project (artifact container)\n            IRuntimeProject prj = engctx.loadProject(\nProjectTest\n + i);\n\n            // process the artifact, get units\n            ILiveArtifact art = prj.processArtifact(new Artifact(file.getName(), new FileInput(file)));\n\n            // proceed with the units\n            List\nIUnit\n units = art.getUnits();\n\n            // TODO: CUSTOMIZE -- this is the important part\n            // Basic tests go here\n            // example:\n            for(IUnit unit: units) {\n                logger.info(\nUnit: %s\n, unit);\n                //if(unit instanceof Xyz) {\n                // ...\n                //}\n            }\n\n            engctx.unloadProject(prj.getKey());\n        }\n\n        // close the engines\n        JebCoreService.getInstance().closeEnginesContext(engctx);\n    }\n}",
            "title": "Writing Front-Ends"
        },
        {
            "location": "/dev/writing-front-ends/index.html#writing-front-ends",
            "text": "JEB front-end are also referred to as \"JEB clients\" (or \"JEB third-party clients\", to contrast with the \"official RCP desktop client\").  JEB back-end API makes writing new clients (aka, front-ends) an easy task. A client can be:   An automated client (for testing, for an automation pipeline)  A command-line client  A graphical front-end (eg, the official RCP desktop client)  ...    Note:  Not all JEB licenses allow the creation of third-party clients. Verify this by checking your license information in the About dialog box. It should show  any-client . Typically,  JEB Pro  licenses allow the execution of third-party clients.",
            "title": "Writing Front-Ends"
        },
        {
            "location": "/dev/writing-front-ends/index.html#high-level-instructions",
            "text": "Use the provided source code template (see below) as a base for your client. The basic steps any client should take are the following:   Use  JebCoreService  to retrieve an instance to  ICoreContext  Create an  IEnginesContext  Load a project within that context ( IRuntimeProject )  Add artifacts and process them ( ILiveArtifact )  Retrieve the products ( IUnit )  Proceed as usual with the units  We recommend developers to read  our tutorial series  on parser development to get familiar with units     Refer to the our  simplified architecture diagrams  to better visualize how those components are connected to one another.",
            "title": "High-level Instructions"
        },
        {
            "location": "/dev/writing-front-ends/index.html#source-template",
            "text": "Full source code:  Command-line client skeleton on GitHub  public class AutoClient {\n    static final ILogger logger = GlobalLog.getLogger(AutoClient.class);\n    static {\n        GlobalLog.addDestinationStream(System.out);\n    }\n\n    // TODO: customize (should be replaced by the LicenseKey entry in your bin/jeb-client.cfg file)\n    private static final String licenseKey =  ... ;\n\n    // TODO: customize\n    private static final String baseDir =  ... ;\n\n    public static void main(String[] argv) throws Exception {\n        if(argv.length  = 0) {\n            return;\n        }\n\n        long t0 = System.currentTimeMillis();\n        String location = argv[0];\n        List File  files = AutoUtil.retrieveFiles(location);\n        test(files);\n        logger.info( Done in %ds , (System.currentTimeMillis() - t0) / 1000);\n    }\n\n    /**\n     * Initialize a core. Create a context within that core. Then, for each input artifact, a\n     * project is created and the artifact is loaded within that project.\n     */\n    public static void test(List File  files) throws Exception {\n        // create or retrieve a core context (engines container)\n        ICoreContext core = JebCoreService.getInstance(licenseKey);\n\n        // create an engines context (project container)\n        IFileDatabase projectdb = new JEB2FileDatabase(baseDir);\n        IFileStore filestore = new SimpleFSFileStore(baseDir);\n        BaseConfiguration cfg = new BaseConfiguration();\n\n        // TODO: customize (alternative is to read your configuration from .cfg file)\n        cfg.setProperty( .DevPluginClasspath ,  ... );\n\n        // TODO: customize\n        cfg.setProperty( .DevPluginClassnames ,  ... );\n\n        IConfiguration config = new CommonsConfigurationWrapper(cfg);\n        IDataProvider dataProvider = new DataProvider(null, projectdb, filestore, null, null, config);\n        IEnginesContext engctx = core.createEnginesContext(dataProvider, null);\n\n        int i = 0;\n        for(File file: files) {\n            i++;\n            logger.info( Testing file %d/%d : %s ... , i, files.size(), file.getName());\n\n            // create or load a project (artifact container)\n            IRuntimeProject prj = engctx.loadProject( ProjectTest  + i);\n\n            // process the artifact, get units\n            ILiveArtifact art = prj.processArtifact(new Artifact(file.getName(), new FileInput(file)));\n\n            // proceed with the units\n            List IUnit  units = art.getUnits();\n\n            // TODO: CUSTOMIZE -- this is the important part\n            // Basic tests go here\n            // example:\n            for(IUnit unit: units) {\n                logger.info( Unit: %s , unit);\n                //if(unit instanceof Xyz) {\n                // ...\n                //}\n            }\n\n            engctx.unloadProject(prj.getKey());\n        }\n\n        // close the engines\n        JebCoreService.getInstance().closeEnginesContext(engctx);\n    }\n}",
            "title": "Source Template"
        },
        {
            "location": "/dev/other-resources/index.html",
            "text": "Additional Resources\n\n\nTechnical drafts for developers: (available on Google Drive)\n\n\n\n\nParser Delegation\n\n\nMVC and Unit Documents\n\n\nPositioning within Units\n\n\nUnits Hierarchy",
            "title": "Additional Resources"
        },
        {
            "location": "/dev/other-resources/index.html#additional-resources",
            "text": "Technical drafts for developers: (available on Google Drive)   Parser Delegation  MVC and Unit Documents  Positioning within Units  Units Hierarchy",
            "title": "Additional Resources"
        },
        {
            "location": "/settings/index.html",
            "text": "Settings\n\n\nThis section describes settings and additional configuration panels offered by the RCP client.\n\n\nStyles and Fonts\n\n\nThe \nEdit\n menu (or the \nApplication\n menu on Mac) allows users to customize the styles of \ninteractive item\n as well as the code font used by most JEB views.\n\n\nMake sure to select a fixed font. JEB tries its best to select the most appropriate font on your system; if that fails, and you wish to select a font manually, we recommend \nConsolas\n on Windows, \nMenlo/Monaco\n on Mac, or \nDejaVu Sans Mono\n on Linux.\n\n\n\n\nUnicode\n: JEB supports Unicode. While the aforementioned fonts have good support for a variery of common non-ASCII planes (CJK, Russian, etc.), you might need to use a different fonts to properly examine strings written in exotic locales.\n\n\n\n\n\n\nLocale\n\n\nThe RCP client front-end is available in English as well as 10 additional languages. Select your preferred language via the \nEdit\n menu:\n\n\n\n\n\n\nNote\n: the back-end components (modules and plugins) are not localized at the moment. Localization is for front-end components only.\n\n\n\n\nEnglish is the main UI language. Other languages have either full or partial support:\n\n\n\n\n\n\n\n\nLanguage\n\n\nSupport as of JEB 2.3.0\n\n\n\n\n\n\n\n\n\n\nEnglish\n\n\ndefault\n\n\n\n\n\n\nFrench\n\n\nfull\n\n\n\n\n\n\nChinese\n\n\nfull\n\n\n\n\n\n\nJapanese\n\n\nfull\n\n\n\n\n\n\nKorean\n\n\nfull\n\n\n\n\n\n\nRussian\n\n\nfull\n\n\n\n\n\n\nGerman\n\n\npartial\n\n\n\n\n\n\nItalian\n\n\npartial\n\n\n\n\n\n\nPortuguese\n\n\npartial\n\n\n\n\n\n\nSpanish\n\n\npartial\n\n\n\n\n\n\nTurkish\n\n\npartial\n\n\n\n\n\n\n\n\nLayouts\n\n\nUsers can (and should!) customize their workspace. It is very common for instance to have a separate view displaying a code hierarchy when analyzing binary code.\n\n\nHowever, users are not limited to a single layout for their workspace:\n\n\n\n\nUse the \nWindow, New Layout...\n entry to duplicate the current layout and customize it.\n\n\nYou may switch layouts at any time via \nWindow, Change Layout \n ...\n.\n\n\n\n\nThe current layout name is always displayed in the right-hand most of the status bar, at the bottom of the main program window.\n\n\n\n\nSimple Options\n\n\nSimple options are accessible via the \nEdit\n or Application menu. Two panels, \nGeneral\n and \nDevelopment\n, offer a partial view of JEB's configuration files, described in upcoming sections. \n\n\nGeneral options\n\n\n\n\nSet-up your \npackaged plugins\n directory. Packaged plugins are third-party Jar modules that add functionality to JEB: they can be parsers, disassemblers, decompilers, debuggers, code analyzers, etc. \nThird-party plugins can be loaded on Pro builds only.\n\n\nCustomize your auto-update options. Proxy (http and socks) are supported.\n\n\n\n\n\n\nDevelopment options\n\n\n\n\nThe \nDevelopment mode\n enables verbose logging for increased insight into the program.\n\n\nThe plugin classpath and classname widgets allow setting up non-packaged Java plugins, which makes developing them easier.",
            "title": "Settings"
        },
        {
            "location": "/settings/index.html#settings",
            "text": "This section describes settings and additional configuration panels offered by the RCP client.",
            "title": "Settings"
        },
        {
            "location": "/settings/index.html#styles-and-fonts",
            "text": "The  Edit  menu (or the  Application  menu on Mac) allows users to customize the styles of  interactive item  as well as the code font used by most JEB views.  Make sure to select a fixed font. JEB tries its best to select the most appropriate font on your system; if that fails, and you wish to select a font manually, we recommend  Consolas  on Windows,  Menlo/Monaco  on Mac, or  DejaVu Sans Mono  on Linux.   Unicode : JEB supports Unicode. While the aforementioned fonts have good support for a variery of common non-ASCII planes (CJK, Russian, etc.), you might need to use a different fonts to properly examine strings written in exotic locales.",
            "title": "Styles and Fonts"
        },
        {
            "location": "/settings/index.html#locale",
            "text": "The RCP client front-end is available in English as well as 10 additional languages. Select your preferred language via the  Edit  menu:    Note : the back-end components (modules and plugins) are not localized at the moment. Localization is for front-end components only.   English is the main UI language. Other languages have either full or partial support:     Language  Support as of JEB 2.3.0      English  default    French  full    Chinese  full    Japanese  full    Korean  full    Russian  full    German  partial    Italian  partial    Portuguese  partial    Spanish  partial    Turkish  partial",
            "title": "Locale"
        },
        {
            "location": "/settings/index.html#layouts",
            "text": "Users can (and should!) customize their workspace. It is very common for instance to have a separate view displaying a code hierarchy when analyzing binary code.  However, users are not limited to a single layout for their workspace:   Use the  Window, New Layout...  entry to duplicate the current layout and customize it.  You may switch layouts at any time via  Window, Change Layout   ... .   The current layout name is always displayed in the right-hand most of the status bar, at the bottom of the main program window.",
            "title": "Layouts"
        },
        {
            "location": "/settings/index.html#simple-options",
            "text": "Simple options are accessible via the  Edit  or Application menu. Two panels,  General  and  Development , offer a partial view of JEB's configuration files, described in upcoming sections.",
            "title": "Simple Options"
        },
        {
            "location": "/settings/index.html#general-options",
            "text": "Set-up your  packaged plugins  directory. Packaged plugins are third-party Jar modules that add functionality to JEB: they can be parsers, disassemblers, decompilers, debuggers, code analyzers, etc.  Third-party plugins can be loaded on Pro builds only.  Customize your auto-update options. Proxy (http and socks) are supported.",
            "title": "General options"
        },
        {
            "location": "/settings/index.html#development-options",
            "text": "The  Development mode  enables verbose logging for increased insight into the program.  The plugin classpath and classname widgets allow setting up non-packaged Java plugins, which makes developing them easier.",
            "title": "Development options"
        },
        {
            "location": "/client-configuration/index.html",
            "text": "Client Configuration\n\n\nThe RCP client stores its \nclient configuration\n, also known as the front-end configuration, in \nbin/jeb-client.cfg\n. The cfg file is a key-value store where keys follow a dot-prefixed, dot-separated naming convention.\n\n\nThe public keys can safely be changed by a user. Those public keys are graphically visible in the \nOptions\n dialog, \nAdvanced\n mode, panel \nClient\n. \n\n\n\n\nMost settings are self-explanatory. \nThis section details settings that require additional details.\n\n\nGeneral\n\n\nGeneral configuration options are located in the anonymous namespace (\n.\n). Most are indirectly settable via the user-friendly \nSimple Options\n panel.\n\n\n.CheckUpdates\n\n\nSelf-explanatory.\n\n\n.DevelopmentMode\n\n\nSelf-explanatory.\n\n\n.IncludeExtraDataInErrorLogs\n\n\nSelf-explanatory.\n\n\n.NetworkProxy\n\n\nSelf-explanatory. \n\n\n.ScriptsFolder\n\n\nSelf-explanatory.\n\n\n.UploadErrorLogs\n\n\nDetermine whether the error log generated by JEB when an exception occurs is also uploaded to our server for further analysis and debugging. We recommend keeping this option true, as it allows us to fix problems transparently and rapidly. The log only contains user and license information, timestamp, and a stacktrace. If the option is false, the log is dumped inside the JEB folder. You may review it, edit it, and email it to us separately if you decide so. \n\n\nRCP Client General\n\n\nGeneral configuration specific to the RCP client.\n\n\n.ui.AlwaysLoadFragments\n\n\nDetermine if unit fragments that support lazy loading should be loaded lazily or eagerly. Not all fragments support lazy loading (an example is the Strings fragment for code units).\n\n\n.ui.AutoAutoDefaultUnit\n\n\nSelf-explanatory.\n\n\n.ui.AutoSavePeriod\n\n\nCurrently not honored\n\n\n.ui.ConsolePartSync\n\n\nSelf-explanatory.\n\n\n.ui.DoNotReplaceViews\n\n\nSelf-explanatory.\n\n\n.ui.ExpandTreeNodesOnFiltering\n\n\nSelf-explanatory.\n\n\n.ui.LoggerMaxLength\n\n\nSelf-explanatory.\n\n\n.ui.ModelLayoutRestorationPolicy\n\n\nDetermine how and if the UI state (most notably, the state of your layouts) can be saved and restored when the RCP persisted state is reset. Custom, back-up persistence is done via \njeb-layout.xml\n.\n\n\n\n\n0: model restoration via is disabled. That means that model persistence is handle by traditional RCP mechanisms only, and will never be maintain across updates requiring a UI state reset.\n\n\n1: model restoration will be enabled only if the RCP persisted state was previously cleared as a one-shot operation. This is the default recommended setting for release builds, as it generally allows a UI state conservation across RCP model updates.\n\n\n2: model restoration triggers every time the RCP persisted state is cleared. This setting is not recommended for non-debug builds.\n\n\n\n\n.ui.NavigationBarPosition\n\n\nTODO\n\n\nRCP Text Views\n\n\nRCP client properties related to interactive text views.\n\n\n.ui.text.AllowLineWrapping\n\n\nTODO\n\n\n.ui.text.CaretBehaviorViewportStatic\n\n\nTODO\n\n\n.ui.text.CharactersPerLineAtEnd\n\n\nTODO\n\n\n.ui.text.CharactersPerLineMax\n\n\nTODO\n\n\n.ui.text.CharactersWrap\n\n\nTODO\n\n\n.ui.text.PageLineSize\n\n\nTODO\n\n\n.ui.text.PageMultiplier\n\n\nTODO\n\n\n.ui.text.ScrollLineSize\n\n\nTODO\n\n\n.ui.text.ShowVerticalScrollbar\n\n\nTODO",
            "title": "Client Configuration"
        },
        {
            "location": "/client-configuration/index.html#client-configuration",
            "text": "The RCP client stores its  client configuration , also known as the front-end configuration, in  bin/jeb-client.cfg . The cfg file is a key-value store where keys follow a dot-prefixed, dot-separated naming convention.  The public keys can safely be changed by a user. Those public keys are graphically visible in the  Options  dialog,  Advanced  mode, panel  Client .    Most settings are self-explanatory.  This section details settings that require additional details.",
            "title": "Client Configuration"
        },
        {
            "location": "/client-configuration/index.html#general",
            "text": "General configuration options are located in the anonymous namespace ( . ). Most are indirectly settable via the user-friendly  Simple Options  panel.",
            "title": "General"
        },
        {
            "location": "/client-configuration/index.html#checkupdates",
            "text": "Self-explanatory.",
            "title": ".CheckUpdates"
        },
        {
            "location": "/client-configuration/index.html#developmentmode",
            "text": "Self-explanatory.",
            "title": ".DevelopmentMode"
        },
        {
            "location": "/client-configuration/index.html#includeextradatainerrorlogs",
            "text": "Self-explanatory.",
            "title": ".IncludeExtraDataInErrorLogs"
        },
        {
            "location": "/client-configuration/index.html#networkproxy",
            "text": "Self-explanatory.",
            "title": ".NetworkProxy"
        },
        {
            "location": "/client-configuration/index.html#scriptsfolder",
            "text": "Self-explanatory.",
            "title": ".ScriptsFolder"
        },
        {
            "location": "/client-configuration/index.html#uploaderrorlogs",
            "text": "Determine whether the error log generated by JEB when an exception occurs is also uploaded to our server for further analysis and debugging. We recommend keeping this option true, as it allows us to fix problems transparently and rapidly. The log only contains user and license information, timestamp, and a stacktrace. If the option is false, the log is dumped inside the JEB folder. You may review it, edit it, and email it to us separately if you decide so.",
            "title": ".UploadErrorLogs"
        },
        {
            "location": "/client-configuration/index.html#rcp-client-general",
            "text": "General configuration specific to the RCP client.",
            "title": "RCP Client General"
        },
        {
            "location": "/client-configuration/index.html#uialwaysloadfragments",
            "text": "Determine if unit fragments that support lazy loading should be loaded lazily or eagerly. Not all fragments support lazy loading (an example is the Strings fragment for code units).",
            "title": ".ui.AlwaysLoadFragments"
        },
        {
            "location": "/client-configuration/index.html#uiautoautodefaultunit",
            "text": "Self-explanatory.",
            "title": ".ui.AutoAutoDefaultUnit"
        },
        {
            "location": "/client-configuration/index.html#uiautosaveperiod",
            "text": "Currently not honored",
            "title": ".ui.AutoSavePeriod"
        },
        {
            "location": "/client-configuration/index.html#uiconsolepartsync",
            "text": "Self-explanatory.",
            "title": ".ui.ConsolePartSync"
        },
        {
            "location": "/client-configuration/index.html#uidonotreplaceviews",
            "text": "Self-explanatory.",
            "title": ".ui.DoNotReplaceViews"
        },
        {
            "location": "/client-configuration/index.html#uiexpandtreenodesonfiltering",
            "text": "Self-explanatory.",
            "title": ".ui.ExpandTreeNodesOnFiltering"
        },
        {
            "location": "/client-configuration/index.html#uiloggermaxlength",
            "text": "Self-explanatory.",
            "title": ".ui.LoggerMaxLength"
        },
        {
            "location": "/client-configuration/index.html#uimodellayoutrestorationpolicy",
            "text": "Determine how and if the UI state (most notably, the state of your layouts) can be saved and restored when the RCP persisted state is reset. Custom, back-up persistence is done via  jeb-layout.xml .   0: model restoration via is disabled. That means that model persistence is handle by traditional RCP mechanisms only, and will never be maintain across updates requiring a UI state reset.  1: model restoration will be enabled only if the RCP persisted state was previously cleared as a one-shot operation. This is the default recommended setting for release builds, as it generally allows a UI state conservation across RCP model updates.  2: model restoration triggers every time the RCP persisted state is cleared. This setting is not recommended for non-debug builds.",
            "title": ".ui.ModelLayoutRestorationPolicy"
        },
        {
            "location": "/client-configuration/index.html#uinavigationbarposition",
            "text": "TODO",
            "title": ".ui.NavigationBarPosition"
        },
        {
            "location": "/client-configuration/index.html#rcp-text-views",
            "text": "RCP client properties related to interactive text views.",
            "title": "RCP Text Views"
        },
        {
            "location": "/client-configuration/index.html#uitextallowlinewrapping",
            "text": "TODO",
            "title": ".ui.text.AllowLineWrapping"
        },
        {
            "location": "/client-configuration/index.html#uitextcaretbehaviorviewportstatic",
            "text": "TODO",
            "title": ".ui.text.CaretBehaviorViewportStatic"
        },
        {
            "location": "/client-configuration/index.html#uitextcharactersperlineatend",
            "text": "TODO",
            "title": ".ui.text.CharactersPerLineAtEnd"
        },
        {
            "location": "/client-configuration/index.html#uitextcharactersperlinemax",
            "text": "TODO",
            "title": ".ui.text.CharactersPerLineMax"
        },
        {
            "location": "/client-configuration/index.html#uitextcharacterswrap",
            "text": "TODO",
            "title": ".ui.text.CharactersWrap"
        },
        {
            "location": "/client-configuration/index.html#uitextpagelinesize",
            "text": "TODO",
            "title": ".ui.text.PageLineSize"
        },
        {
            "location": "/client-configuration/index.html#uitextpagemultiplier",
            "text": "TODO",
            "title": ".ui.text.PageMultiplier"
        },
        {
            "location": "/client-configuration/index.html#uitextscrolllinesize",
            "text": "TODO",
            "title": ".ui.text.ScrollLineSize"
        },
        {
            "location": "/client-configuration/index.html#uitextshowverticalscrollbar",
            "text": "TODO",
            "title": ".ui.text.ShowVerticalScrollbar"
        },
        {
            "location": "/engines-configuration/index.html",
            "text": "Engines Configuration\n\n\nThe RCP client stores the JEB \nengines configurations\n, also known as the back-end configuration, in the \nbin/jeb-engines.cfg\n. The cfg file is a key-value store where keys follow a dot-prefixed, dot-separated naming convention.\n\n\nThis file contains general back-end settings as well as the settings of common plugins shipped with most distributions of JEB. Each plugin has its own sub-namespace (\n.PluginType\n) within the \n.parsers\n namespace.\n\n\n)\n\n\nMany settings are self-explanatory. This section will detail only those settings requiring additional details.\n\n\nGeneral\n\n\n.DatabaseBackupBeforeSave\n\n\nSince the persistence of each unit in a project is ultimately decided by the plugin responsible for that unit, errors in plugin code may generate JDB2 database corruption. When this option is true, the current JDB2 database is always backed up before attempting to save and overwite it. It is highly recommended to leave this setting on its default value (true).\n\n\n.NetworkProxy\n\n\nSimilar to the similarly named client option. This setting holds proxy settings for the back-end. They must be set when third-party clients are used.\n\n\n.parsers.EnforceVersionChecks\n\n\nDetermine if the minimum and maximum JEB version requirements specified in plugins is enforced by JEB. For instance, a plugin specifying a minimum JEB version of 2.2.1 will be rejected by JEB if its version is less than 2.2.1. It is recommended to leave this option as true.\n\n\n.project.ArtifactProcessingDepth\n\n\nTODO\n\n\n.project.CompressPersistedProject\n\n\nDetermine if the JDB2 database should be compressed before being persisted to disk.\n\n\nAndroid APK Plugin\n\n\n.parsers.apk.FrameworksDirectory\n\n\nTODO\n\n\n.parsers.apk.ParseBytecode\n\n\nTODO\n\n\n.parsers.apk.TryMergeMultiDex\n\n\nTODO\n\n\nAndroid DEX Plugin\n\n\n.parsers.dex.VerifyVersion\n\n\nTODO\n\n\n.parsers.dex.VerifyHashes\n\n\nTODO\n\n\n.parsers.dex.VerifyAccessFlags\n\n\nTODO\n\n\n.parsers.dex.ParseExtendedOpcodes\n\n\nTODO\n\n\n.parsers.dex.ParseOptimizedOpcodes\n\n\nTODO\n\n\n.parsers.dex.asm.ShowAddresses\n\n\nTODO\n\n\n.parsers.dex.asm.ShowBytecode\n\n\nTODO\n\n\n.parsers.dex.asm.ClassSeparator\n\n\nTODO\n\n\n.parsers.dex.asm.MethodSeparator\n\n\nTODO\n\n\n.parsers.dex.asm.ShowAnnotations\n\n\nTODO\n\n\n.parsers.dex.asm.ShowDebugDirectives\n\n\nTODO\n\n\n.parsers.dex.asm.ShowLineNumbers\n\n\nTODO\n\n\n.parsers.dex.asm.UsePForParameters\n\n\nTODO\n\n\n.parsers.dex.asm.BlankLinesAfterBlocks\n\n\nTODO\n\n\n.parsers.dex.asm.SmaliCompatibility\n\n\nTODO\n\n\n.parsers.dex.WellKnownLibraryPackages\n\n\nTODO\n\n\nandroid\nandroid_src\ncom.google\njava\njavax\norg.acra\norg.json\norg.apache\n\n\n\nDEX Decompiler Plugin\n\n\nThe following settings are used to customize the decompilation process.\n\n\n.parsers.dcmp_dex.ParseExceptionBlocks\n\n\nSelf-explanatory.\n\n\n.parsers.dcmp_dex.ParseDebugInformation\n\n\nParse the debug information of the DEX file to extract and use metadata such as method parameter names.\n\n\n\n\nNote\n: metadata can be forged and should not be trusted.\n\n\n\n\n.parsers.dcmp_dex.AggressiveSubstitutions\n\n\nAllow aggressive function substitutions during the IR optimization pass.\n\n\n.parsers.dcmp_dex.OptimizeStringConcatenation\n\n\nRebuild string concatenation out of from string builders (eg, \n\"foo\" + \"bar\"\n) when possible.\n\n\n.parsers.dcmp_dex.OptimizeInlineSyntheticAccessCalls\n\n\nAttempt to inline compiler-generated (synthetic) access calls (eg, when accessing inner class attributes from outer classes) when possible.\n\n\n.parsers.dcmp_dex.OptimizeCreateForLoops\n\n\nRebuild for-loops from while-loops when possible.\n\n\n.parsers.dcmp_dex.OptimizeCreateVarArgs\n\n\nRebuild variable argument calls when possible. \n\n\n.parsers.dcmp_dex.OptimizeCreateMultiDimArrays\n\n\nRebuild multi-dimensional arrays when possible.\n\n\n.parsers.dcmp_dex.OptimizeCreateConditionalAssignments\n\n\nRebuild tertiary (\n?:\n) assignments when possible.\n\n\n.parsers.dcmp_dex.GenerateNumbersInHex\n\n\nTODO\n\n\n.parsers.dcmp_dex.PortDebugParameterNames\n\n\nTODO\n\n\n.parsers.dcmp_dex.DisplayPrivateMethodsLast\n\n\nTODO\n\n\n.parsers.dcmp_dex.InsertBlankLinesAfterCompounds\n\n\nTODO\n\n\n.parsers.dcmp_dex.GenerateSyntheticFields\n\n\nTODO\n\n\n.parsers.dcmp_dex.GenerateSyntheticMethods\n\n\nTODO\n\n\n.parsers.dcmp_dex.GenerateAnnotations\n\n\nTODO\n\n\n.parsers.dcmp_dex.java.DisplayPrivateMethodsLast\n\n\nTODO\n\n\n.parsers.dcmp_dex.java.GenerateAnnotations\n\n\nTODO\n\n\n.parsers.dcmp_dex.java.GenerateNumbersInHex\n\n\nTODO\n\n\n.parsers.dcmp_dex.java.GenerateSyntheticFields\n\n\nTODO\n\n\n.parsers.dcmp_dex.java.GenerateSyntheticMethods\n\n\nTODO\n\n\n.parsers.dcmp_dex.java.InsertBlankLinesAfterCompounds\n\n\nTODO\n\n\n.parsers.dcmp_dex.java.PortDebugParameterNames\n\n\nTODO\n\n\nXML Plugin\n\n\n.parsers.xml.ParseComments\n\n\nParse and display XML comments (inside \n!-- ... --\n tags). Enabled by default.\n\n\nAndroid Debugger Plugin\n\n\n.parsers.dbug_apk.AttachPortRangeSize\n\n\nTODO\n\n\n.parsers.dbug_apk.AttachPortRangeStart\n\n\nTODO\n\n\n.parsers.dbug_apk.BlockingQueryTimeoutSeconds\n\n\nTODO\n\n\n.parsers.dbug_apk.PreferredGdbserverVersion\n\n\nTODO\n\n\n.parsers.dbug_apk.UseNativeDebugger\n\n\nTODO\n\n\n.parsers.dbug_apk.NativeAttachPortRangeSize\n\n\nTODO\n\n\n.parsers.dbug_apk.NativeAttachPortRangeStart\n\n\nTODO\n\n\nProject-specific Options\n\n\nThe engines configuration acts as a template for your projects' settings. Once within a project, an additional tab named \nProject-Specific\n allows the user to modify the back-end settings of the project only, without changing the global back-end settings.",
            "title": "Engines Configuration"
        },
        {
            "location": "/engines-configuration/index.html#engines-configuration",
            "text": "The RCP client stores the JEB  engines configurations , also known as the back-end configuration, in the  bin/jeb-engines.cfg . The cfg file is a key-value store where keys follow a dot-prefixed, dot-separated naming convention.  This file contains general back-end settings as well as the settings of common plugins shipped with most distributions of JEB. Each plugin has its own sub-namespace ( .PluginType ) within the  .parsers  namespace.  )  Many settings are self-explanatory. This section will detail only those settings requiring additional details.",
            "title": "Engines Configuration"
        },
        {
            "location": "/engines-configuration/index.html#general",
            "text": "",
            "title": "General"
        },
        {
            "location": "/engines-configuration/index.html#databasebackupbeforesave",
            "text": "Since the persistence of each unit in a project is ultimately decided by the plugin responsible for that unit, errors in plugin code may generate JDB2 database corruption. When this option is true, the current JDB2 database is always backed up before attempting to save and overwite it. It is highly recommended to leave this setting on its default value (true).",
            "title": ".DatabaseBackupBeforeSave"
        },
        {
            "location": "/engines-configuration/index.html#networkproxy",
            "text": "Similar to the similarly named client option. This setting holds proxy settings for the back-end. They must be set when third-party clients are used.",
            "title": ".NetworkProxy"
        },
        {
            "location": "/engines-configuration/index.html#parsersenforceversionchecks",
            "text": "Determine if the minimum and maximum JEB version requirements specified in plugins is enforced by JEB. For instance, a plugin specifying a minimum JEB version of 2.2.1 will be rejected by JEB if its version is less than 2.2.1. It is recommended to leave this option as true.",
            "title": ".parsers.EnforceVersionChecks"
        },
        {
            "location": "/engines-configuration/index.html#projectartifactprocessingdepth",
            "text": "TODO",
            "title": ".project.ArtifactProcessingDepth"
        },
        {
            "location": "/engines-configuration/index.html#projectcompresspersistedproject",
            "text": "Determine if the JDB2 database should be compressed before being persisted to disk.",
            "title": ".project.CompressPersistedProject"
        },
        {
            "location": "/engines-configuration/index.html#android-apk-plugin",
            "text": "",
            "title": "Android APK Plugin"
        },
        {
            "location": "/engines-configuration/index.html#parsersapkframeworksdirectory",
            "text": "TODO",
            "title": ".parsers.apk.FrameworksDirectory"
        },
        {
            "location": "/engines-configuration/index.html#parsersapkparsebytecode",
            "text": "TODO",
            "title": ".parsers.apk.ParseBytecode"
        },
        {
            "location": "/engines-configuration/index.html#parsersapktrymergemultidex",
            "text": "TODO",
            "title": ".parsers.apk.TryMergeMultiDex"
        },
        {
            "location": "/engines-configuration/index.html#android-dex-plugin",
            "text": "",
            "title": "Android DEX Plugin"
        },
        {
            "location": "/engines-configuration/index.html#parsersdexverifyversion",
            "text": "TODO",
            "title": ".parsers.dex.VerifyVersion"
        },
        {
            "location": "/engines-configuration/index.html#parsersdexverifyhashes",
            "text": "TODO",
            "title": ".parsers.dex.VerifyHashes"
        },
        {
            "location": "/engines-configuration/index.html#parsersdexverifyaccessflags",
            "text": "TODO",
            "title": ".parsers.dex.VerifyAccessFlags"
        },
        {
            "location": "/engines-configuration/index.html#parsersdexparseextendedopcodes",
            "text": "TODO",
            "title": ".parsers.dex.ParseExtendedOpcodes"
        },
        {
            "location": "/engines-configuration/index.html#parsersdexparseoptimizedopcodes",
            "text": "TODO",
            "title": ".parsers.dex.ParseOptimizedOpcodes"
        },
        {
            "location": "/engines-configuration/index.html#parsersdexasmshowaddresses",
            "text": "TODO",
            "title": ".parsers.dex.asm.ShowAddresses"
        },
        {
            "location": "/engines-configuration/index.html#parsersdexasmshowbytecode",
            "text": "TODO",
            "title": ".parsers.dex.asm.ShowBytecode"
        },
        {
            "location": "/engines-configuration/index.html#parsersdexasmclassseparator",
            "text": "TODO",
            "title": ".parsers.dex.asm.ClassSeparator"
        },
        {
            "location": "/engines-configuration/index.html#parsersdexasmmethodseparator",
            "text": "TODO",
            "title": ".parsers.dex.asm.MethodSeparator"
        },
        {
            "location": "/engines-configuration/index.html#parsersdexasmshowannotations",
            "text": "TODO",
            "title": ".parsers.dex.asm.ShowAnnotations"
        },
        {
            "location": "/engines-configuration/index.html#parsersdexasmshowdebugdirectives",
            "text": "TODO",
            "title": ".parsers.dex.asm.ShowDebugDirectives"
        },
        {
            "location": "/engines-configuration/index.html#parsersdexasmshowlinenumbers",
            "text": "TODO",
            "title": ".parsers.dex.asm.ShowLineNumbers"
        },
        {
            "location": "/engines-configuration/index.html#parsersdexasmusepforparameters",
            "text": "TODO",
            "title": ".parsers.dex.asm.UsePForParameters"
        },
        {
            "location": "/engines-configuration/index.html#parsersdexasmblanklinesafterblocks",
            "text": "TODO",
            "title": ".parsers.dex.asm.BlankLinesAfterBlocks"
        },
        {
            "location": "/engines-configuration/index.html#parsersdexasmsmalicompatibility",
            "text": "TODO",
            "title": ".parsers.dex.asm.SmaliCompatibility"
        },
        {
            "location": "/engines-configuration/index.html#parsersdexwellknownlibrarypackages",
            "text": "TODO  android\nandroid_src\ncom.google\njava\njavax\norg.acra\norg.json\norg.apache",
            "title": ".parsers.dex.WellKnownLibraryPackages"
        },
        {
            "location": "/engines-configuration/index.html#dex-decompiler-plugin",
            "text": "The following settings are used to customize the decompilation process.",
            "title": "DEX Decompiler Plugin"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexparseexceptionblocks",
            "text": "Self-explanatory.",
            "title": ".parsers.dcmp_dex.ParseExceptionBlocks"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexparsedebuginformation",
            "text": "Parse the debug information of the DEX file to extract and use metadata such as method parameter names.   Note : metadata can be forged and should not be trusted.",
            "title": ".parsers.dcmp_dex.ParseDebugInformation"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexaggressivesubstitutions",
            "text": "Allow aggressive function substitutions during the IR optimization pass.",
            "title": ".parsers.dcmp_dex.AggressiveSubstitutions"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexoptimizestringconcatenation",
            "text": "Rebuild string concatenation out of from string builders (eg,  \"foo\" + \"bar\" ) when possible.",
            "title": ".parsers.dcmp_dex.OptimizeStringConcatenation"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexoptimizeinlinesyntheticaccesscalls",
            "text": "Attempt to inline compiler-generated (synthetic) access calls (eg, when accessing inner class attributes from outer classes) when possible.",
            "title": ".parsers.dcmp_dex.OptimizeInlineSyntheticAccessCalls"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexoptimizecreateforloops",
            "text": "Rebuild for-loops from while-loops when possible.",
            "title": ".parsers.dcmp_dex.OptimizeCreateForLoops"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexoptimizecreatevarargs",
            "text": "Rebuild variable argument calls when possible.",
            "title": ".parsers.dcmp_dex.OptimizeCreateVarArgs"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexoptimizecreatemultidimarrays",
            "text": "Rebuild multi-dimensional arrays when possible.",
            "title": ".parsers.dcmp_dex.OptimizeCreateMultiDimArrays"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexoptimizecreateconditionalassignments",
            "text": "Rebuild tertiary ( ?: ) assignments when possible.",
            "title": ".parsers.dcmp_dex.OptimizeCreateConditionalAssignments"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexgeneratenumbersinhex",
            "text": "TODO",
            "title": ".parsers.dcmp_dex.GenerateNumbersInHex"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexportdebugparameternames",
            "text": "TODO",
            "title": ".parsers.dcmp_dex.PortDebugParameterNames"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexdisplayprivatemethodslast",
            "text": "TODO",
            "title": ".parsers.dcmp_dex.DisplayPrivateMethodsLast"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexinsertblanklinesaftercompounds",
            "text": "TODO",
            "title": ".parsers.dcmp_dex.InsertBlankLinesAfterCompounds"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexgeneratesyntheticfields",
            "text": "TODO",
            "title": ".parsers.dcmp_dex.GenerateSyntheticFields"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexgeneratesyntheticmethods",
            "text": "TODO",
            "title": ".parsers.dcmp_dex.GenerateSyntheticMethods"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexgenerateannotations",
            "text": "TODO",
            "title": ".parsers.dcmp_dex.GenerateAnnotations"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexjavadisplayprivatemethodslast",
            "text": "TODO",
            "title": ".parsers.dcmp_dex.java.DisplayPrivateMethodsLast"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexjavagenerateannotations",
            "text": "TODO",
            "title": ".parsers.dcmp_dex.java.GenerateAnnotations"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexjavageneratenumbersinhex",
            "text": "TODO",
            "title": ".parsers.dcmp_dex.java.GenerateNumbersInHex"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexjavageneratesyntheticfields",
            "text": "TODO",
            "title": ".parsers.dcmp_dex.java.GenerateSyntheticFields"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexjavageneratesyntheticmethods",
            "text": "TODO",
            "title": ".parsers.dcmp_dex.java.GenerateSyntheticMethods"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexjavainsertblanklinesaftercompounds",
            "text": "TODO",
            "title": ".parsers.dcmp_dex.java.InsertBlankLinesAfterCompounds"
        },
        {
            "location": "/engines-configuration/index.html#parsersdcmp_dexjavaportdebugparameternames",
            "text": "TODO",
            "title": ".parsers.dcmp_dex.java.PortDebugParameterNames"
        },
        {
            "location": "/engines-configuration/index.html#xml-plugin",
            "text": "",
            "title": "XML Plugin"
        },
        {
            "location": "/engines-configuration/index.html#parsersxmlparsecomments",
            "text": "Parse and display XML comments (inside  !-- ... --  tags). Enabled by default.",
            "title": ".parsers.xml.ParseComments"
        },
        {
            "location": "/engines-configuration/index.html#android-debugger-plugin",
            "text": "",
            "title": "Android Debugger Plugin"
        },
        {
            "location": "/engines-configuration/index.html#parsersdbug_apkattachportrangesize",
            "text": "TODO",
            "title": ".parsers.dbug_apk.AttachPortRangeSize"
        },
        {
            "location": "/engines-configuration/index.html#parsersdbug_apkattachportrangestart",
            "text": "TODO",
            "title": ".parsers.dbug_apk.AttachPortRangeStart"
        },
        {
            "location": "/engines-configuration/index.html#parsersdbug_apkblockingquerytimeoutseconds",
            "text": "TODO",
            "title": ".parsers.dbug_apk.BlockingQueryTimeoutSeconds"
        },
        {
            "location": "/engines-configuration/index.html#parsersdbug_apkpreferredgdbserverversion",
            "text": "TODO",
            "title": ".parsers.dbug_apk.PreferredGdbserverVersion"
        },
        {
            "location": "/engines-configuration/index.html#parsersdbug_apkusenativedebugger",
            "text": "TODO",
            "title": ".parsers.dbug_apk.UseNativeDebugger"
        },
        {
            "location": "/engines-configuration/index.html#parsersdbug_apknativeattachportrangesize",
            "text": "TODO",
            "title": ".parsers.dbug_apk.NativeAttachPortRangeSize"
        },
        {
            "location": "/engines-configuration/index.html#parsersdbug_apknativeattachportrangestart",
            "text": "TODO",
            "title": ".parsers.dbug_apk.NativeAttachPortRangeStart"
        },
        {
            "location": "/engines-configuration/index.html#project-specific-options",
            "text": "The engines configuration acts as a template for your projects' settings. Once within a project, an additional tab named  Project-Specific  allows the user to modify the back-end settings of the project only, without changing the global back-end settings.",
            "title": "Project-specific Options"
        },
        {
            "location": "/floating/index.html",
            "text": "Floating Controllers\n\n\nConcept\n\n\nFloating builds provide more flexibility than individual builds, and can be distributed to many users within an organization. A floating build licensed for N seats will allow N JEB clients to connect to it concurrently. When a client leaves, its seat is vacated, allowing another client to connect to the Controller.\n\n\nCurrently, only the \nPro Floating version\n of JEB2 supports floating licenses.\n\n\n\n\nWhen starting, as well as during its execution, JEB will regularly probe the Controller to determine whether or not it is allowed to run. This check is based on the number of seats available in your licensed build: eg, a floating license for 5 seats allows 5 different users to run JEB concurrently.\n\n\nIn order to start the Controller, use the \n--controller\n flag along with the \n-c\n flag. Example on a Linux machine:\n\n\n$ jeb_linux.sh -c --controller\n\n\n\nIn order to start JEB, proceed as usual, for instance on Windows:\n\n\n$ jeb_wincon.bat\n\n\n\nTechnical notes:\n\n\n\n\nThe JEB client as well as the Controller are the same binary file: there is no separate package for the Controller.\n\n\nThe '--controller' flag is not available if the build is not a floating one.\n\n\nThe Controller must be started before the clients.\n\n\nJEB instances regularly contact the Controller. Therefore, the Controller should always be reachable by running instances of JEB. In order to minimize potential problems due to network latency, it is recommended to run JEB and the Controller within the same local network.\n\n\nBy default, the Controller listens on all interfaces, on port 23477. This can be changed by setting the '.ControllerInterface' and '.ControllerPort' flags in the configuration file (as explained later in this document).\n\n\nThe protocol used for communication between a Controller and JEB instances is HTTP, therefore eliminating potential firewall blocking issues.\n\n\nJEB instances and the Controller may be run in different environments (as in the example above: Controller on Linux, JEB on Windows, etc.)\n\n\nThe controller property '.ControllerMessage' is used to provide messages, visible by clients on the Controller portal.\n\n\n\n\nInitial Execution\n\n\n\n\nNote\n: starting with JEB version 2.2.10, the floating controller no longer requires a support package to run. Whether the machine that will run the controller is connected to the internet or not, simply run the startup script with \n-c --controller\n, and follow the initial installation steps. Then, proceed with section \nController Settings\n.\n\n\n\n\nOn a machine connected to the Internet\n\n\nIf the machine executing the controller is connected to the Internet, the following will happen:\n\n\n\n\nThe support package will be downloaded automatically\n\n\nJust follow the prompt: input your password, accept the EULA, generate a license key\n\n\n\n\nSample log output:\n\n\nC:\\jeb\njeb_wincon.bat -c --controller\nDownloading jeb2-sp-win64-v2.zip...\nReading 36675855 bytes: 9\n8\n7\n6\n5\n4\n3\n2\n1\n0\nCopying file...\nSuccess\nJEB decryption password: ***************\n...\n...\n\nEULA\n\n\nGoverning Law, Jurisdiction and Costs\nThis Agreement shall be governed, construed, and enforced in accordance with the laws of the State of California, without regard to its conflict of laws rules.\n\nSeverability\nIf any provision of this Agreement shall be held to be invalid or unenforceable, the remainder of this Agreement shall remain in full force and effect. To the extent any express or implied restrictions are not permitted by applicable laws, these express or implied restrictions shall remain in force and effect to the maximum extent permitted by such applicable laws.\nWrite \nyes\n to agree, then press enter: yes\nHello Nicolas Falliere. Set up your JEB controller by generating a license key. This one-time operation will only take a few seconds.\nPlease visit https://www.pnfsoftware.com/genlk, and use the following \nlicense data\n blob to generate a key\nLicense data: .............................................\nInput your license key: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nMode: Controller for floating clients\nNote: X client(s) may simultaneously connect to this controller instance\nListening on 0.0.0.0/0.0.0.0:23477...\n\n\n\n\nOn a machine NOT connected to the Internet\n\n\nIf the machine executing the controller is not connected to the Internet, the following will happen:\n\n\n\n\nThe support package cannot be downloaded\n\n\nIf you are running JEB version 2.2.9 or below, the installation will fail; if you are running JEB 2.2.10 or above, the support package is no longer required (see note above), and you may proceed\n\n\n\n\nSample log output when the download fails: (JEB 2.2.9-)\n\n\nC:\\jeb\njeb_wincon.bat -c --controller\nDownloading jeb2-sp-win64-v2.zip...\nA network error occurred\nDownload error.\nIf this system is offline, please visit https://www.pnfsoftware.com/jeb2/downloads to manually retrieve the support package.\nThe support package was not dropped\n\n\n\n\nYou will have to download a support package manually, and drop it in your \nbin/\n folder. Instructions and download links can be found here: https://www.pnfsoftware.com/jeb2/downloads \n\n\nController Settings\n\n\nAfter the first step is completed successfully, executing the controller should display something like the following:\n\n\nC:\\jeb\njeb_wincon.bat -c --controller\nMode: Controller for floating clients\nNote: X client(s) may simultaneously connect to this controller instance\nListening on 0.0.0.0/0.0.0.0:23477...\n\n\n\n\nAs can be seen, by default, the controller is listening on port 23477 on all interfaces. This can be changed by editing the file \nbin/jeb-client.cfg\n and adding two entries named \n.ControllerInterface\n and \n.ControllerPort\n.\n\n\nFor example, if you wish to listen exclusively on localhost, port 30000:\n\n\n.ControllerInterface = localhost\n.ControllerPort = 35000\n\n\n\n\nUpdating the Controller\n\n\nThere is no auto-update feature in the controller. The update procedure is:\n\n\n\n\nCheck your registered email address for a JEB update email (\n\"JEB xxx is available...\"\n)\n\n\nDownload the software archive\n\n\nCopy the archive to the root of your JEB folder and rename the file to \nupdate.zip\n\n\nCreate a text file named \nupdate.pwd\n\n\nStore the email-provided password inside this file\n\n\nStart your controller as normal (eg, \n... -c --controller\n); the update will be installed automatically",
            "title": "Floating Controller"
        },
        {
            "location": "/floating/index.html#floating-controllers",
            "text": "",
            "title": "Floating Controllers"
        },
        {
            "location": "/floating/index.html#concept",
            "text": "Floating builds provide more flexibility than individual builds, and can be distributed to many users within an organization. A floating build licensed for N seats will allow N JEB clients to connect to it concurrently. When a client leaves, its seat is vacated, allowing another client to connect to the Controller.  Currently, only the  Pro Floating version  of JEB2 supports floating licenses.   When starting, as well as during its execution, JEB will regularly probe the Controller to determine whether or not it is allowed to run. This check is based on the number of seats available in your licensed build: eg, a floating license for 5 seats allows 5 different users to run JEB concurrently.  In order to start the Controller, use the  --controller  flag along with the  -c  flag. Example on a Linux machine:  $ jeb_linux.sh -c --controller  In order to start JEB, proceed as usual, for instance on Windows:  $ jeb_wincon.bat  Technical notes:   The JEB client as well as the Controller are the same binary file: there is no separate package for the Controller.  The '--controller' flag is not available if the build is not a floating one.  The Controller must be started before the clients.  JEB instances regularly contact the Controller. Therefore, the Controller should always be reachable by running instances of JEB. In order to minimize potential problems due to network latency, it is recommended to run JEB and the Controller within the same local network.  By default, the Controller listens on all interfaces, on port 23477. This can be changed by setting the '.ControllerInterface' and '.ControllerPort' flags in the configuration file (as explained later in this document).  The protocol used for communication between a Controller and JEB instances is HTTP, therefore eliminating potential firewall blocking issues.  JEB instances and the Controller may be run in different environments (as in the example above: Controller on Linux, JEB on Windows, etc.)  The controller property '.ControllerMessage' is used to provide messages, visible by clients on the Controller portal.",
            "title": "Concept"
        },
        {
            "location": "/floating/index.html#initial-execution",
            "text": "Note : starting with JEB version 2.2.10, the floating controller no longer requires a support package to run. Whether the machine that will run the controller is connected to the internet or not, simply run the startup script with  -c --controller , and follow the initial installation steps. Then, proceed with section  Controller Settings .",
            "title": "Initial Execution"
        },
        {
            "location": "/floating/index.html#on-a-machine-connected-to-the-internet",
            "text": "If the machine executing the controller is connected to the Internet, the following will happen:   The support package will be downloaded automatically  Just follow the prompt: input your password, accept the EULA, generate a license key   Sample log output:  C:\\jeb jeb_wincon.bat -c --controller\nDownloading jeb2-sp-win64-v2.zip...\nReading 36675855 bytes: 9 8 7 6 5 4 3 2 1 0\nCopying file...\nSuccess\nJEB decryption password: ***************\n...\n... EULA \n\nGoverning Law, Jurisdiction and Costs\nThis Agreement shall be governed, construed, and enforced in accordance with the laws of the State of California, without regard to its conflict of laws rules.\n\nSeverability\nIf any provision of this Agreement shall be held to be invalid or unenforceable, the remainder of this Agreement shall remain in full force and effect. To the extent any express or implied restrictions are not permitted by applicable laws, these express or implied restrictions shall remain in force and effect to the maximum extent permitted by such applicable laws.\nWrite  yes  to agree, then press enter: yes\nHello Nicolas Falliere. Set up your JEB controller by generating a license key. This one-time operation will only take a few seconds.\nPlease visit https://www.pnfsoftware.com/genlk, and use the following  license data  blob to generate a key\nLicense data: .............................................\nInput your license key: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nMode: Controller for floating clients\nNote: X client(s) may simultaneously connect to this controller instance\nListening on 0.0.0.0/0.0.0.0:23477...",
            "title": "On a machine connected to the Internet"
        },
        {
            "location": "/floating/index.html#on-a-machine-not-connected-to-the-internet",
            "text": "If the machine executing the controller is not connected to the Internet, the following will happen:   The support package cannot be downloaded  If you are running JEB version 2.2.9 or below, the installation will fail; if you are running JEB 2.2.10 or above, the support package is no longer required (see note above), and you may proceed   Sample log output when the download fails: (JEB 2.2.9-)  C:\\jeb jeb_wincon.bat -c --controller\nDownloading jeb2-sp-win64-v2.zip...\nA network error occurred\nDownload error.\nIf this system is offline, please visit https://www.pnfsoftware.com/jeb2/downloads to manually retrieve the support package.\nThe support package was not dropped  You will have to download a support package manually, and drop it in your  bin/  folder. Instructions and download links can be found here: https://www.pnfsoftware.com/jeb2/downloads",
            "title": "On a machine NOT connected to the Internet"
        },
        {
            "location": "/floating/index.html#controller-settings",
            "text": "After the first step is completed successfully, executing the controller should display something like the following:  C:\\jeb jeb_wincon.bat -c --controller\nMode: Controller for floating clients\nNote: X client(s) may simultaneously connect to this controller instance\nListening on 0.0.0.0/0.0.0.0:23477...  As can be seen, by default, the controller is listening on port 23477 on all interfaces. This can be changed by editing the file  bin/jeb-client.cfg  and adding two entries named  .ControllerInterface  and  .ControllerPort .  For example, if you wish to listen exclusively on localhost, port 30000:  .ControllerInterface = localhost\n.ControllerPort = 35000",
            "title": "Controller Settings"
        },
        {
            "location": "/floating/index.html#updating-the-controller",
            "text": "There is no auto-update feature in the controller. The update procedure is:   Check your registered email address for a JEB update email ( \"JEB xxx is available...\" )  Download the software archive  Copy the archive to the root of your JEB folder and rename the file to  update.zip  Create a text file named  update.pwd  Store the email-provided password inside this file  Start your controller as normal (eg,  ... -c --controller ); the update will be installed automatically",
            "title": "Updating the Controller"
        },
        {
            "location": "/faq/index.html",
            "text": "FAQ\n\n\nFrequently asked answers to common questions and issues.\n\n\nLicensing\n\n\nWhere is the end-user license agreement?\n\n\nThe up-to-date end-user license agreement for JEB can be found \nhere\n.\n\n\nCan I generate license keys for additional machines?\n\n\nYes, as long as the additional machines are operated by the licensee, they may install JEB on them. Contact \nsupport\n to request the ability to generate additional keys. We handle those requests promptly.\n\n\nCan I revoke former license keys?\n\n\nYes, oler JEB license keys can be deprecated. Contact \nsupport\n to request key revokation. We handle those requests promptly.\n\n\nHow do I check my license type, license identifier, or license key?\n\n\nFrom the command-line: execute JEB with the \n-c --license\n switches, eg:\n\n\n$ jeb_wincon.bat -c --license\n\n\n\nFrom the RCP client: open the menu entry \nHelp, About\n.\n\n\nHow do floating licenses work?\n\n\nFloating licenses work on a \nper-seat\n basis, as opposed to other license types that work on a \nper-user\n basis. Example:\n\n\n\n\nA floating build valid for 3 seats allow any 3 users within your organization concurrently.\n\n\nA non-floating build valid for 3 users allow 3 fixed, determined users to use JEB. No other user can use it.\n\n\n\n\nTherefore, floating builds provide great flexibility for organizations where many users are planning to use JEB irregularly and/or at different times (eg, teams split across various regions).\n\n\nYou will find additional details, including technical notes, \nin the setup instructions page\n.\n\n\nWhat happens when my license subscription expires?\n\n\nJEB works on subscription. Past the expiration date, the software will stop working. You may renew a license as early as 3 months before your expiration date.\n\n\nDo subscriptions renew automatically?\n\n\nNo. We do not perform auto-payments or auto-renewals. Please email sales when you need to renew a subscription.\n\n\nDo you offer subscriptions valid for more than one year?\n\n\nYes, we do offer custom subscriptions for up to 3 years. Email us at \nsales\n for details.\n\n\nDo you offer perpetual licenses?\n\n\nNo, we do not offer perpetual licenses at this point. In any case, email \nsales\n and let us know your specific needs: we always strive to accommodate our customer's needs.\n\n\nDo you offer large volume subscriptions?\n\n\nYes, we do have plans for large enterprise and government. Those plans include the possibility to generate large amount of license keys. Reach out to \nsales\n for additional details.\n\n\nWe developed internal tools built around JEB. Can other users in my organization use them without breaking the EULA?\n\n\nYes. As long as your JEB subscription is valid, users in your organization may access and use data produced by JEB.\n\n\nJava\n\n\nJEB complains that it \"requires a Java runtime environment\", although I have one installed.\n\n\nYour \njava\n binary should be accessible from the \nPATH\n environment variable. It is also recommended to set a \nJAVA_HOME\n environment variable pointing to your Java installation folder (bin/).\n\n\nIf you are running on a 64-bit system, we recommend you install and use a 64-bit Java environment. A common source of problems are 64-bit systems having a 32-bit JRE accessible from the PATH. You may have different versions of Java installed, but always make sure that the PATH refers to one that matches your system specifications.\n\n\nHow can I increase the maximum amount of memory usable by JEB?\n\n\nIf unspecified, the memory cap is automatically decided upon starting up - and it will almost certainly be lower than what your system can offer.\n\n\nIn order to manually specify the maximum amount of memory usable by JEB, edit the file \nbin/jeb.ini\n located in your JEB folder. Add the following lines:\n\n\n-vmargs\n-Xmx????m\n\n\n\nReplace \n????\n by the size amount of your choice (in Mb), eg, \n4096\n to allow JEB to use up to 4Gb.\n\n\n\n\nNote\n: other Java Virtual Machine options may be provided after the \n-vmargs\n (one option per line). Refer to your JVM manual for a complete list of options.\n\n\n\n\nOn startup, messages in the logger output should reflect the updated capability:\n\n\n\n\nI just upgraded to Java 8u131 or above (or Java 7u131), and JEB would close immediately after start-up\n\n\nThe probable reason is that you must be using JEB 2.2.10 or below. Older versions of JEB are no compatible with the newer JDK/SDK. There are two ways to solve this problem:\n\n\n\n\n\n\nIf you wish to stay on the JEB 2.2.x branch, install the latest update 2.2.11. You may use Java 7 or Java 8.\n\n\n\n\n\n\nWe recommend you upgrade to the latest version of JEB, on the 2.3.x branch at the time of writing. \nMake sure to use Java 8\n: the JEB 2.3 UI client requires it. Note that the JEB back-end (jeb.jar) still works fine with Java 7; if you are using JEB for automation only and do not use the UI client, you may keep using Java 7.\n\n\n\n\n\n\nCan I use Java 9?\n\n\nAt the moment, the desktop client does not work with Java 9; you will have to use Java 8 in order to run it.\n\n\nHowever, the back-end components (\njeb.jar\n) work fine with with Java 9.\n\n\nProgram\n\n\nCan I run JEB on \n[Platform Name]\n?\n\n\nThe RCP client (aka the official JEB UI desktop client) runs on Windows, Linux, and Mac OS, both in their 32-bit and 64-bit versions.\n\n\nThe JEB back-end components, which can be used separately to build other clients or analysis pipelines, run on all systems for which a Java Runtime Environment version 7 or above is available.\n\n\nHow can I run multiple instances of JEB?\n\n\nStart your second and more instances of the RCP client by using the \n-data @none\n command-line argument.\n\n\nExample on Windows:\n\n\n$ jeb_wincon.bat -data @none\n\n\n\nNote that the customization of your UI workspace will not be ported over to this new instance, and will not be persisted upon closing either.\n\n\nJEB closes unexpectedly at start-up. How do I troubleshoot potential issues?\n\n\nBy default, console messages are logged to the \nworkspace/*log\n or \nworkspace/.metadata/.log\n file within your JEB directory.\nIf you are using the RCP client, adding those settings to your \nbin/jeb.ini\n file will instruct the RCP framework to log debug messages to the console:\n\n\n-debug\n-consoleLog\n-noExit\n\n\n\nMake sure to add them before any \n-vmarg\n parameter!\n\n\nRestart JEB and examine the console log. If all else fails, please reach out to \nSupport\n.\n\n\nUI\n\n\nJEB messages and strings are in my current (non-English) locale. How do I switch to English?\n\n\nBy default, JEB does its best to display messages in the current user's language settings. You may change the locale to English (or another one of the \n10 supported languages\n) via the \nEdit, Language\n menu. See the \nSettings\n for details.\n\n\nI cannot find menu entry \n[xxx]\n, where is it?\n\n\nYou may need to reset the user interface state, via the \nReset, UI State\n menu entry. A hard reset is to remove your \nworkspace/\n folder within your JEB installation folder.\n\n\nWhat are the views marked as \"Unbound\" in the RCP Client?\n\n\nThose entries are layout placeholders from previous JEB sessions. They help JEB determine the best location to display a unit of a given type. (Note that \"Unbound Views\" can be closed at any time.)\n\n\nIn the example below, DEX views and Java Decompiled views would be opened in their corresponding placeholders before attempting to create additional views.\n\n\n\n\nUpdating\n\n\nI work in a limited-connectivity environment, how can I update the software manually?\n\n\nIf you are updating from JEB 2.2.5 or above, simply follow the prompt when JEB starts up or follow the procedure when executing the menu entry \nHelp, Software Update\n.\n\n\nIf you are updating from JEB 2.2.4 or below, the procedure is the following:\n\n\n\n\nCheck your registered email address for a JEB update email (\n\"JEB xxx is available...\"\n)\n\n\nDownload the software archive\n\n\nCopy the archive to the root of your JEB folder and rename the file to \nupdate.zip\n\n\nCreate a text file named \nupdate.pwd\n\n\nStore the email-provided password inside this file\n\n\nStart JEB as normal; the update will be installed automatically\n\n\n\n\nI access Internet via a proxy. Can I still use JEB?\n\n\nThe answer is yes. Basic proxy settings are stored at those two locations:\n\n\n\n\nthe client's settings, stored in \njeb-client.cfg\n. If you are using the RCP desktop client, this data can be modified via the Options panel.\n  This setting is optional, and should be set if you'd like to receive and install updates automatically through the software.\n\n\nthe back-end's settings, stored in \njeb-engines.cfg\n. \nIn this case, the configuration file must be edited manually.\n\n  This setting is \nmandatory if your license type requires an active Internet connection\n, as is the case for \nStandard\n and \nDemo\n builds.\n\n\n\n\nIn each aforementioned configuration file, the network proxy data is stored as a key-value pair having the following format:\n    .NetworkProxy = type|hostname|port\n\n\nAllowed types include \nhttp\n and \nsocks\n.\n\n\nProxy authentication:\n If access to the proxy requires an authenticated user, the following Java variables must be set up when running JEB:\n\n\n[proxytype].proxyUser\n and \n[proxytype].proxyPassword\n\n\nproxytype\n is to be replaced by the actual proxy type, eg, \nhttp\n.\n\n\nSetting up these variables in Java is done by providing them to the Java VM using the \n-D\n option flag. If you are using the RCP desktop client, the simplest way to achieve this is to edit \njeb.ini\n located in the \nbin/\n folder, and append the following lines:\n\n\n-vmargs\n-Dhttp.proxyUser=your_username\n-Dhttp.proxyPassword=your_password\n\n\n\nI have troubles updating from JEB 2.2 to JEB 2.3\n\n\nMake sure that:\n\n\n\n\nyou are using Java 8: JEB 2.3.x UI client requires Java 8 to function properly (see separate entry above for details)\n\n\nthe support package v4 was installed: JEB 2.3 requires the \nUI support package version 4\n; if it was not downloaded automatically, you may drop the zip archive of the support package matching your system's specs in the JEB's \nbin/\n folder.\n\n\nyou may forcibly reset the client by removing the JEB's \nbin/workspace/\n folder\n\n\n\n\nIf the above steps did not work, reach out to support or consider installing JEB 2.3 from scratch in a separate location.\n\n\nCan I update from the command-line?\n\n\nYes. Starting with JEB 2.3.5, simply run:\n\n\n$ \njeb_startup_script\n -c --check-update\n\n\nAfter the update is downloaded, execute JEB normally. \n\n\nScripting\n\n\nCan I execute a JEB Python script from the command line?\n\n\nYes. The proper way would be to create a headless client that wraps around a Jython interpreter. Read through \nthis guide\n and associated sample code if you want to know more about writing your own front-end clients.\n\n\nFor convenience, we integrated such a client within the \njeb.jar\n core file. Here is how to use it: (You will need a \nPro\n license)\n\n\n\n\nMake sure to drop a copy of Jython stand-alone JAR into your \nscripts\n folder\n\n\nNavigate to your JEB folder, sub-folder \nbin/cl\n\n\nExecute jeb.jar with \n--srv2\n and \n--script\n parameters, as well as optional script arguments (preceded by \n--\n)\n\n\n\n\nExample:\n\n\n$ java -jar jeb.jar --srv2 --script=JEB2SampleScript.py -- foo bar\n\n\n\n\n\nNote\n: The command-line arguments (foo, bar, ...) can be retrieved via [IClientContext] https://www.pnfsoftware.com/jeb2/apidoc/reference/com/pnfsoftware/jeb/client/api/IClientContext.html#getArguments()).\n\n\n\n\nHow to execute a JEB Python script from the command line with JEB 2.3.4 (or older)?\n\n\nFor reference, here is how to run Python scripts in a headless environment with JEB 2.3.4 or older: \n\n\n\n\nMake sure to drop a copy of Jython stand-alone JAR into your \nscripts\n folder\n\n\nNavigate to your JEB folder, sub-folder \nbin/cl\n\n\nExecute jeb.jar with \n--script\n and \n--libdir\n parameters, as well as optional script arguments (preceded by \n--\n)\n\n\nAlso remember to set up two Java properties, using \n-Dkey=value\n command-lines flags:\n\n\njeb.engcfg\n: points to your \njeb-engines.cfg\n file\n\n\njeb.lickey\n: contains a valid JEB license key (such as the value referenced in \n.LicenseKey\n in your \njeb-client.cfg\n file)\n\n\n\n\n\n\n\n\nExample:\n\n\n$ java -Djeb.engcfg=jeb-engines.cfg -Djeb.lickey=xxxxxxx -jar jeb.jar --script=1.py --libdir=xxxxx -- arg1 arg2 ...\n\n\n\n\n\nNote\n: The command-line arguments (arg1,  arg2, ...) can be retrieved via \nIClientContext\n.\n\n\n\n\nCan I write back-end extensions (plugins, contributions, etc.) in Python?\n\n\nSoon! If all goes according to plan, we open support for Python back-end extensions starting with JEB 2.3.6.\n\n\nOther\n\n\nIs there a public bug/feature tracker?\n\n\nNot at the moment. We are pretty responsive when it comes to answering users' queries though. \nEmail\n us or ask your question on the \nJEB Google Groups\n.",
            "title": "FAQ"
        },
        {
            "location": "/faq/index.html#faq",
            "text": "Frequently asked answers to common questions and issues.",
            "title": "FAQ"
        },
        {
            "location": "/faq/index.html#licensing",
            "text": "",
            "title": "Licensing"
        },
        {
            "location": "/faq/index.html#where-is-the-end-user-license-agreement",
            "text": "The up-to-date end-user license agreement for JEB can be found  here .",
            "title": "Where is the end-user license agreement?"
        },
        {
            "location": "/faq/index.html#can-i-generate-license-keys-for-additional-machines",
            "text": "Yes, as long as the additional machines are operated by the licensee, they may install JEB on them. Contact  support  to request the ability to generate additional keys. We handle those requests promptly.",
            "title": "Can I generate license keys for additional machines?"
        },
        {
            "location": "/faq/index.html#can-i-revoke-former-license-keys",
            "text": "Yes, oler JEB license keys can be deprecated. Contact  support  to request key revokation. We handle those requests promptly.",
            "title": "Can I revoke former license keys?"
        },
        {
            "location": "/faq/index.html#how-do-i-check-my-license-type-license-identifier-or-license-key",
            "text": "From the command-line: execute JEB with the  -c --license  switches, eg:  $ jeb_wincon.bat -c --license  From the RCP client: open the menu entry  Help, About .",
            "title": "How do I check my license type, license identifier, or license key?"
        },
        {
            "location": "/faq/index.html#how-do-floating-licenses-work",
            "text": "Floating licenses work on a  per-seat  basis, as opposed to other license types that work on a  per-user  basis. Example:   A floating build valid for 3 seats allow any 3 users within your organization concurrently.  A non-floating build valid for 3 users allow 3 fixed, determined users to use JEB. No other user can use it.   Therefore, floating builds provide great flexibility for organizations where many users are planning to use JEB irregularly and/or at different times (eg, teams split across various regions).  You will find additional details, including technical notes,  in the setup instructions page .",
            "title": "How do floating licenses work?"
        },
        {
            "location": "/faq/index.html#what-happens-when-my-license-subscription-expires",
            "text": "JEB works on subscription. Past the expiration date, the software will stop working. You may renew a license as early as 3 months before your expiration date.",
            "title": "What happens when my license subscription expires?"
        },
        {
            "location": "/faq/index.html#do-subscriptions-renew-automatically",
            "text": "No. We do not perform auto-payments or auto-renewals. Please email sales when you need to renew a subscription.",
            "title": "Do subscriptions renew automatically?"
        },
        {
            "location": "/faq/index.html#do-you-offer-subscriptions-valid-for-more-than-one-year",
            "text": "Yes, we do offer custom subscriptions for up to 3 years. Email us at  sales  for details.",
            "title": "Do you offer subscriptions valid for more than one year?"
        },
        {
            "location": "/faq/index.html#do-you-offer-perpetual-licenses",
            "text": "No, we do not offer perpetual licenses at this point. In any case, email  sales  and let us know your specific needs: we always strive to accommodate our customer's needs.",
            "title": "Do you offer perpetual licenses?"
        },
        {
            "location": "/faq/index.html#do-you-offer-large-volume-subscriptions",
            "text": "Yes, we do have plans for large enterprise and government. Those plans include the possibility to generate large amount of license keys. Reach out to  sales  for additional details.",
            "title": "Do you offer large volume subscriptions?"
        },
        {
            "location": "/faq/index.html#we-developed-internal-tools-built-around-jeb-can-other-users-in-my-organization-use-them-without-breaking-the-eula",
            "text": "Yes. As long as your JEB subscription is valid, users in your organization may access and use data produced by JEB.",
            "title": "We developed internal tools built around JEB. Can other users in my organization use them without breaking the EULA?"
        },
        {
            "location": "/faq/index.html#java",
            "text": "",
            "title": "Java"
        },
        {
            "location": "/faq/index.html#jeb-complains-that-it-requires-a-java-runtime-environment-although-i-have-one-installed",
            "text": "Your  java  binary should be accessible from the  PATH  environment variable. It is also recommended to set a  JAVA_HOME  environment variable pointing to your Java installation folder (bin/).  If you are running on a 64-bit system, we recommend you install and use a 64-bit Java environment. A common source of problems are 64-bit systems having a 32-bit JRE accessible from the PATH. You may have different versions of Java installed, but always make sure that the PATH refers to one that matches your system specifications.",
            "title": "JEB complains that it \"requires a Java runtime environment\", although I have one installed."
        },
        {
            "location": "/faq/index.html#how-can-i-increase-the-maximum-amount-of-memory-usable-by-jeb",
            "text": "If unspecified, the memory cap is automatically decided upon starting up - and it will almost certainly be lower than what your system can offer.  In order to manually specify the maximum amount of memory usable by JEB, edit the file  bin/jeb.ini  located in your JEB folder. Add the following lines:  -vmargs\n-Xmx????m  Replace  ????  by the size amount of your choice (in Mb), eg,  4096  to allow JEB to use up to 4Gb.   Note : other Java Virtual Machine options may be provided after the  -vmargs  (one option per line). Refer to your JVM manual for a complete list of options.   On startup, messages in the logger output should reflect the updated capability:",
            "title": "How can I increase the maximum amount of memory usable by JEB?"
        },
        {
            "location": "/faq/index.html#i-just-upgraded-to-java-8u131-or-above-or-java-7u131-and-jeb-would-close-immediately-after-start-up",
            "text": "The probable reason is that you must be using JEB 2.2.10 or below. Older versions of JEB are no compatible with the newer JDK/SDK. There are two ways to solve this problem:    If you wish to stay on the JEB 2.2.x branch, install the latest update 2.2.11. You may use Java 7 or Java 8.    We recommend you upgrade to the latest version of JEB, on the 2.3.x branch at the time of writing.  Make sure to use Java 8 : the JEB 2.3 UI client requires it. Note that the JEB back-end (jeb.jar) still works fine with Java 7; if you are using JEB for automation only and do not use the UI client, you may keep using Java 7.",
            "title": "I just upgraded to Java 8u131 or above (or Java 7u131), and JEB would close immediately after start-up"
        },
        {
            "location": "/faq/index.html#can-i-use-java-9",
            "text": "At the moment, the desktop client does not work with Java 9; you will have to use Java 8 in order to run it.  However, the back-end components ( jeb.jar ) work fine with with Java 9.",
            "title": "Can I use Java 9?"
        },
        {
            "location": "/faq/index.html#program",
            "text": "",
            "title": "Program"
        },
        {
            "location": "/faq/index.html#can-i-run-jeb-on-platform-name",
            "text": "The RCP client (aka the official JEB UI desktop client) runs on Windows, Linux, and Mac OS, both in their 32-bit and 64-bit versions.  The JEB back-end components, which can be used separately to build other clients or analysis pipelines, run on all systems for which a Java Runtime Environment version 7 or above is available.",
            "title": "Can I run JEB on [Platform Name]?"
        },
        {
            "location": "/faq/index.html#how-can-i-run-multiple-instances-of-jeb",
            "text": "Start your second and more instances of the RCP client by using the  -data @none  command-line argument.  Example on Windows:  $ jeb_wincon.bat -data @none  Note that the customization of your UI workspace will not be ported over to this new instance, and will not be persisted upon closing either.",
            "title": "How can I run multiple instances of JEB?"
        },
        {
            "location": "/faq/index.html#jeb-closes-unexpectedly-at-start-up-how-do-i-troubleshoot-potential-issues",
            "text": "By default, console messages are logged to the  workspace/*log  or  workspace/.metadata/.log  file within your JEB directory.\nIf you are using the RCP client, adding those settings to your  bin/jeb.ini  file will instruct the RCP framework to log debug messages to the console:  -debug\n-consoleLog\n-noExit  Make sure to add them before any  -vmarg  parameter!  Restart JEB and examine the console log. If all else fails, please reach out to  Support .",
            "title": "JEB closes unexpectedly at start-up. How do I troubleshoot potential issues?"
        },
        {
            "location": "/faq/index.html#ui",
            "text": "",
            "title": "UI"
        },
        {
            "location": "/faq/index.html#jeb-messages-and-strings-are-in-my-current-non-english-locale-how-do-i-switch-to-english",
            "text": "By default, JEB does its best to display messages in the current user's language settings. You may change the locale to English (or another one of the  10 supported languages ) via the  Edit, Language  menu. See the  Settings  for details.",
            "title": "JEB messages and strings are in my current (non-English) locale. How do I switch to English?"
        },
        {
            "location": "/faq/index.html#i-cannot-find-menu-entry-xxx-where-is-it",
            "text": "You may need to reset the user interface state, via the  Reset, UI State  menu entry. A hard reset is to remove your  workspace/  folder within your JEB installation folder.",
            "title": "I cannot find menu entry [xxx], where is it?"
        },
        {
            "location": "/faq/index.html#what-are-the-views-marked-as-unbound-in-the-rcp-client",
            "text": "Those entries are layout placeholders from previous JEB sessions. They help JEB determine the best location to display a unit of a given type. (Note that \"Unbound Views\" can be closed at any time.)  In the example below, DEX views and Java Decompiled views would be opened in their corresponding placeholders before attempting to create additional views.",
            "title": "What are the views marked as \"Unbound\" in the RCP Client?"
        },
        {
            "location": "/faq/index.html#updating",
            "text": "",
            "title": "Updating"
        },
        {
            "location": "/faq/index.html#i-work-in-a-limited-connectivity-environment-how-can-i-update-the-software-manually",
            "text": "If you are updating from JEB 2.2.5 or above, simply follow the prompt when JEB starts up or follow the procedure when executing the menu entry  Help, Software Update .  If you are updating from JEB 2.2.4 or below, the procedure is the following:   Check your registered email address for a JEB update email ( \"JEB xxx is available...\" )  Download the software archive  Copy the archive to the root of your JEB folder and rename the file to  update.zip  Create a text file named  update.pwd  Store the email-provided password inside this file  Start JEB as normal; the update will be installed automatically",
            "title": "I work in a limited-connectivity environment, how can I update the software manually?"
        },
        {
            "location": "/faq/index.html#i-access-internet-via-a-proxy-can-i-still-use-jeb",
            "text": "The answer is yes. Basic proxy settings are stored at those two locations:   the client's settings, stored in  jeb-client.cfg . If you are using the RCP desktop client, this data can be modified via the Options panel.\n  This setting is optional, and should be set if you'd like to receive and install updates automatically through the software.  the back-end's settings, stored in  jeb-engines.cfg .  In this case, the configuration file must be edited manually. \n  This setting is  mandatory if your license type requires an active Internet connection , as is the case for  Standard  and  Demo  builds.   In each aforementioned configuration file, the network proxy data is stored as a key-value pair having the following format:\n    .NetworkProxy = type|hostname|port  Allowed types include  http  and  socks .  Proxy authentication:  If access to the proxy requires an authenticated user, the following Java variables must be set up when running JEB:  [proxytype].proxyUser  and  [proxytype].proxyPassword  proxytype  is to be replaced by the actual proxy type, eg,  http .  Setting up these variables in Java is done by providing them to the Java VM using the  -D  option flag. If you are using the RCP desktop client, the simplest way to achieve this is to edit  jeb.ini  located in the  bin/  folder, and append the following lines:  -vmargs\n-Dhttp.proxyUser=your_username\n-Dhttp.proxyPassword=your_password",
            "title": "I access Internet via a proxy. Can I still use JEB?"
        },
        {
            "location": "/faq/index.html#i-have-troubles-updating-from-jeb-22-to-jeb-23",
            "text": "Make sure that:   you are using Java 8: JEB 2.3.x UI client requires Java 8 to function properly (see separate entry above for details)  the support package v4 was installed: JEB 2.3 requires the  UI support package version 4 ; if it was not downloaded automatically, you may drop the zip archive of the support package matching your system's specs in the JEB's  bin/  folder.  you may forcibly reset the client by removing the JEB's  bin/workspace/  folder   If the above steps did not work, reach out to support or consider installing JEB 2.3 from scratch in a separate location.",
            "title": "I have troubles updating from JEB 2.2 to JEB 2.3"
        },
        {
            "location": "/faq/index.html#can-i-update-from-the-command-line",
            "text": "Yes. Starting with JEB 2.3.5, simply run:  $  jeb_startup_script  -c --check-update  After the update is downloaded, execute JEB normally.",
            "title": "Can I update from the command-line?"
        },
        {
            "location": "/faq/index.html#scripting",
            "text": "",
            "title": "Scripting"
        },
        {
            "location": "/faq/index.html#can-i-execute-a-jeb-python-script-from-the-command-line",
            "text": "Yes. The proper way would be to create a headless client that wraps around a Jython interpreter. Read through  this guide  and associated sample code if you want to know more about writing your own front-end clients.  For convenience, we integrated such a client within the  jeb.jar  core file. Here is how to use it: (You will need a  Pro  license)   Make sure to drop a copy of Jython stand-alone JAR into your  scripts  folder  Navigate to your JEB folder, sub-folder  bin/cl  Execute jeb.jar with  --srv2  and  --script  parameters, as well as optional script arguments (preceded by  -- )   Example:  $ java -jar jeb.jar --srv2 --script=JEB2SampleScript.py -- foo bar   Note : The command-line arguments (foo, bar, ...) can be retrieved via [IClientContext] https://www.pnfsoftware.com/jeb2/apidoc/reference/com/pnfsoftware/jeb/client/api/IClientContext.html#getArguments()).",
            "title": "Can I execute a JEB Python script from the command line?"
        },
        {
            "location": "/faq/index.html#how-to-execute-a-jeb-python-script-from-the-command-line-with-jeb-234-or-older",
            "text": "For reference, here is how to run Python scripts in a headless environment with JEB 2.3.4 or older:    Make sure to drop a copy of Jython stand-alone JAR into your  scripts  folder  Navigate to your JEB folder, sub-folder  bin/cl  Execute jeb.jar with  --script  and  --libdir  parameters, as well as optional script arguments (preceded by  -- )  Also remember to set up two Java properties, using  -Dkey=value  command-lines flags:  jeb.engcfg : points to your  jeb-engines.cfg  file  jeb.lickey : contains a valid JEB license key (such as the value referenced in  .LicenseKey  in your  jeb-client.cfg  file)     Example:  $ java -Djeb.engcfg=jeb-engines.cfg -Djeb.lickey=xxxxxxx -jar jeb.jar --script=1.py --libdir=xxxxx -- arg1 arg2 ...   Note : The command-line arguments (arg1,  arg2, ...) can be retrieved via  IClientContext .",
            "title": "How to execute a JEB Python script from the command line with JEB 2.3.4 (or older)?"
        },
        {
            "location": "/faq/index.html#can-i-write-back-end-extensions-plugins-contributions-etc-in-python",
            "text": "Soon! If all goes according to plan, we open support for Python back-end extensions starting with JEB 2.3.6.",
            "title": "Can I write back-end extensions (plugins, contributions, etc.) in Python?"
        },
        {
            "location": "/faq/index.html#other",
            "text": "",
            "title": "Other"
        },
        {
            "location": "/faq/index.html#is-there-a-public-bugfeature-tracker",
            "text": "Not at the moment. We are pretty responsive when it comes to answering users' queries though.  Email  us or ask your question on the  JEB Google Groups .",
            "title": "Is there a public bug/feature tracker?"
        }
    ]
}